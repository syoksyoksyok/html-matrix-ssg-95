<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multigrain Player - CTRL Matrix (Enhanced Random Controls)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --label-font-size: 0.8rem; 
      --spacing-unit: 8px;
    }

    body {
      font-family: "MS Sans Serif", sans-serif;
      background: #c0c0c0;
      color: black;
      margin: 0;
      padding: var(--spacing-unit);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      position: relative;
    }

    .layout-container {
      width: 100%;
      max-width: 900px;
      position: relative;
      min-height: 600px;
    }

    .layout-container.free-layout {
      height: 100vh;
      max-width: none;
      width: 100vw;
      padding: 20px;
      box-sizing: border-box;
    }

    .layout-toggle {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 2000;
      background: #e0e0e0;
      border: 2px outset #fff;
      padding: 5px 10px;
      cursor: pointer;
      font-size: 0.8em;
      font-weight: bold;
    }

    .layout-toggle:active {
      border: 2px inset #808080;
    }

    .auto-arrange-btn {
      position: fixed;
      top: 10px;
      left: 140px;
      z-index: 2000;
      background: #d0d0f0;
      border: 1px outset #fff;
      padding: 3px 6px;
      cursor: pointer;
      font-size: 0.7em;
      font-weight: bold;
      display: none;
      transition: background-color 0.2s;
    }

    .auto-arrange-btn:hover {
      background: #c0c0e0;
    }

    .auto-arrange-btn:active {
      border: 1px inset #808080;
    }

    .auto-arrange-btn.show {
      display: block;
    }

    h2 {
      background: #000080;
      color: white;
      padding: calc(var(--spacing-unit) / 2) var(--spacing-unit);
      border: 2px outset #fff;
      margin-top: 0;
      margin-bottom: var(--spacing-unit);
      width: 100%;
      box-sizing: border-box;
      text-align: center;
    }

    .panel-group {
      border: 2px outset #fff;
      background: #e0e0e0;
      padding: var(--spacing-unit);
      margin-bottom: var(--spacing-unit);
      width: 100%;
      max-width: 900px;
      box-sizing: border-box;
      position: relative;
      overflow: visible;
    }

    .panel-group.draggable {
      position: absolute;
      z-index: 1000;
      box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3);
      transition: none;
      overflow: visible;
      min-width: 200px;
      min-height: 150px;
    }

    .panel-group.dragging {
      opacity: 0.8;
      transform: scale(1.02);
      z-index: 1001;
    }

    .panel-group.resizing {
      opacity: 0.9;
      z-index: 1001;
    }

    .resize-handle {
      position: absolute;
      width: 20px;
      height: 20px;
      background: #808080;
      border: 2px outset #fff;
      cursor: se-resize;
      bottom: -2px;
      right: -2px;
      z-index: 1002;
      display: block;
    }

    .resize-handle:hover {
      background: #606060;
    }

    .resize-handle:active {
      border: 2px inset #808080;
    }

    .resize-handle::before {
      content: '';
      position: absolute;
      bottom: 3px;
      right: 3px;
      width: 8px;
      height: 8px;
      background: linear-gradient(-45deg, transparent 30%, #404040 30%, #404040 32%, transparent 32%, transparent 38%, #404040 38%, #404040 40%, transparent 40%);
      pointer-events: none;
    }

    .panel-group:hover {
      border-color: #808080;
    }

    .group-title {
      background: #000080;
      color: white;
      padding: 4px 10px;
      border: 2px outset #fff;
      margin-top: 0;
      margin-bottom: var(--spacing-unit);
      font-size: 1em;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .panel-group.draggable .group-title {
      cursor: grab;
    }

    .panel-group.dragging .group-title {
      cursor: grabbing;
    }

    .panel-group.draggable .group-title.no-collapse {
      cursor: grab;
    }

    .panel-group.dragging .group-title.no-collapse {
      cursor: grabbing;
    }

    .group-title .indicator {
        font-weight: bold;
        margin-left: 10px;
        font-size: 1.2em;
    }

    .collapsed-content {
        display: none;
    }

    .form-element {
      background-color: #fff;
      border: 2px inset #808080;
      font-family: "MS Sans Serif", sans-serif;
      padding: 4px;
      margin-top: 2px;
      width: calc(100% - 8px);
      box-sizing: border-box;
    }

    label span {
      color: #000080;
      font-weight: bold;
    }

    button {
      background: #e0e0e0;
      border: 2px outset #fff;
      padding: 8px 15px;
      margin-top: var(--spacing-unit);
      margin-right: calc(var(--spacing-unit) / 2);
      cursor: pointer;
      font-size: 1rem;
    }

    button:active {
      border: 2px inset #808080;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .performance-monitor {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #c0c0c0;
      border: 2px outset #fff;
      font-family: "MS Sans Serif", sans-serif;
      font-size: 11px;
      z-index: 1000;
      min-width: 220px;
      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .performance-monitor.hidden {
      display: none;
    }

    .perf-title-bar {
      background: linear-gradient(90deg, #000080 0%, #000040 100%);
      color: white;
      padding: 2px 4px;
      font-weight: bold;
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #808080;
    }

    .perf-title-icon {
      width: 16px;
      height: 16px;
      background: #c0c0c0;
      border: 1px outset #fff;
      display: inline-block;
      margin-right: 4px;
      position: relative;
    }

    .perf-title-icon::before {
      content: 'üìä';
      position: absolute;
      top: -2px;
      left: 1px;
      font-size: 12px;
    }

    .perf-content {
      padding: 8px;
      background: #c0c0c0;
    }

    .perf-section {
      margin-bottom: 6px;
      border: 1px inset #808080;
      background: white;
      padding: 4px;
    }

    .perf-section-title {
      font-weight: bold;
      color: #000080;
      margin-bottom: 3px;
      font-size: 10px;
    }

    .meter-row {
      display: flex;
      justify-content: space-between;
      margin: 2px 0;
      font-size: 10px;
      align-items: center;
    }

    .meter-label {
      color: #000;
      font-weight: normal;
    }

    .meter-value {
      font-weight: bold;
      font-family: 'Courier New', monospace;
      padding: 1px 3px;
      border: 1px inset #808080;
      background: #ffffff;
      min-width: 50px;
      text-align: center;
    }

    .meter-bar {
      width: 60px;
      height: 8px;
      border: 1px inset #808080;
      background: #c0c0c0;
      margin-left: 4px;
      position: relative;
      overflow: hidden;
    }

    .meter-fill {
      height: 100%;
      background: linear-gradient(90deg, #008000 0%, #ffff00 70%, #ff0000 100%);
      transition: width 0.2s ease;
      border-right: 1px solid #000;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border: 1px outset #fff;
      margin-left: 4px;
      display: inline-block;
    }

    .status-running { background: #00ff00; }
    .status-suspended { background: #ffff00; }
    .status-error { background: #ff0000; }

    .warning .meter-value { 
      color: #ff8800; 
      background: #fff8e0;
    }
    .error .meter-value { 
      color: #cc0000; 
      background: #ffe0e0;
    }

    .perf-minimize-btn {
      background: #c0c0c0;
      border: 1px outset #fff;
      width: 16px;
      height: 14px;
      font-size: 8px;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
      line-height: 12px;
    }

    .perf-minimize-btn:active {
      border: 1px inset #808080;
    }

    .waveform-canvas {
      border: 2px inset #808080;
      background: #000;
      margin-top: 4px;
      margin-bottom: var(--spacing-unit);
      width: 100%;
      max-width: 250px;
      height: 80px;
      cursor: grab;
      box-sizing: border-box;
    }

    .waveform-canvas:active {
      cursor: grabbing;
    }

    .waveform-display-container {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      padding-bottom: 5px;
    }

    .sequencer-row {
      display: flex;
      gap: 2px;
      margin-bottom: 4px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .step {
      width: 28px;
      height: 28px;
      font-size: 0.8rem;
      text-align: center;
      line-height: 28px;
      background: #ccc;
      border: 1px solid #666;
      cursor: pointer;
      flex-shrink: 0;
    }

    .step.active {
      background: green;
      color: white;
    }

    .step.current {
      border: 2px solid red;
    }

    .step.selected {
      border: 2px solid blue;
      box-shadow: 0 0 4px rgba(0, 0, 255, 0.5);
    }

    .step.multi-selected {
      border: 2px solid orange;
      box-shadow: 0 0 4px rgba(255, 165, 0, 0.5);
    }

    .slot-matrix {
      display: grid;
      grid-template-columns: auto repeat(15, minmax(45px, 1fr));
      gap: 1px 2px;
      padding: 6px;
      align-items: center;
      justify-items: center;
    }

    .slot-matrix .header-cell,
    .slot-matrix .label-cell,
    .slot-matrix .control-cell {
      padding: 1px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .slot-matrix .label-cell {
      text-align: right;
      font-weight: bold;
      color: #000080;
      white-space: nowrap;
      font-size: var(--label-font-size);
      align-items: flex-end;
      justify-content: center;
      padding-right: 2px;
    }

    .slot-matrix .control-cell label {
      display: block;
      margin-bottom: 5px;
      font-size: var(--label-font-size);
    }

    .slot-matrix .control-cell label input[type="range"] {
      width: 95%;
    }

    .slot-matrix .control-cell label span {
      font-weight: normal;
      color: black;
      margin-left: 5px;
    }

    .param-header-cell {
      text-align: center;
      font-weight: bold;
      color: #000080;
      font-size: var(--label-font-size);
      writing-mode: vertical-rl;
      text-orientation: mixed;
      padding: 2px;
      min-height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
    }

    .param-header-with-button {
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100%;
      justify-content: space-around;
      width: 100%;
    }

    .param-header-text {
      writing-mode: vertical-rl;
      text-orientation: mixed;
      white-space: nowrap;
      flex: 1;
      display: flex;
      align-items: center;
    }

    .param-button-group {
      display: flex;
      flex-direction: row;
      gap: 0;
      align-items: center;
      justify-content: center;
    }

    .param-random-btn {
      width: 15px;
      height: 19px;
      border: 1px outset #fff;
      background: #e0e0e0;
      cursor: pointer;
      font-size: 10px;
      font-weight: bold;
      font-family: "MS Sans Serif", sans-serif;
      color: #000;
      text-align: center;
      line-height: 17px;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
      transform: rotate(-90deg);
      flex-shrink: 0;
      transition: background-color 0.2s;
      position: relative;
    }

    .param-random-btn::before {
      content: 'R';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(90deg);
      font-size: 10px;
      font-weight: bold;
    }

    .param-random-btn:hover {
      background: #d0d0d0;
    }

    .param-random-btn:active {
      border: 1px inset #808080;
    }

    .param-random-btn.flash {
      background: #80ff80;
    }

    .param-reset-btn {
      width: 15px;
      height: 19px;
      border: 1px outset #fff;
      background: #f0e0e0;
      cursor: pointer;
      font-size: 10px;
      font-weight: bold;
      font-family: "MS Sans Serif", sans-serif;
      color: #000;
      text-align: center;
      line-height: 17px;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
      transform: rotate(-90deg);
      flex-shrink: 0;
      transition: background-color 0.2s;
      position: relative;
    }

    .param-reset-btn::before {
      content: '0';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(90deg);
      font-size: 10px;
      font-weight: bold;
      color: #800000;
    }

    .param-reset-btn:hover {
      background: #e0d0d0;
    }

    .param-reset-btn:active {
      border: 1px inset #808080;
    }

    .param-reset-btn.flash {
      background: #ff8080;
    }

    .param-lock-btn {
      width: 15px;
      height: 19px;
      border: 1px outset #fff;
      background: #e0f0e0;
      cursor: pointer;
      font-size: 10px;
      font-weight: bold;
      font-family: "MS Sans Serif", sans-serif;
      color: #000;
      text-align: center;
      line-height: 17px;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
      transform: rotate(-90deg);
      flex-shrink: 0;
      transition: background-color 0.2s;
      position: relative;
    }

    .param-lock-btn::before {
      content: 'L';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(90deg);
      font-size: 10px;
      font-weight: bold;
      color: #006000;
    }

    .param-lock-btn:hover {
      background: #d0e0d0;
    }

    .param-lock-btn:active {
      border: 1px inset #808080;
    }

    .param-lock-btn.flash {
      background: #80ff80;
    }

    .param-lock-btn.locked::before {
      content: 'U';
      color: #800000;
    }

    .param-lock-btn.locked {
      background: #ffe0e0;
    }

    .param-lock-btn.locked:hover {
      background: #f0d0d0;
    }

    .matrix-knob {
      text-align: center;
      padding: 2px;
      margin: 0;
    }

    .matrix-knob .knob {
      width: 35px;
      height: 35px;
      margin: 0 auto 2px;
    }

    .matrix-knob .knob-face {
      width: 31px;
      height: 31px;
      top: 2px;
      left: 2px;
    }

    .matrix-knob .knob-indicator {
      width: 2px;
      height: 10px;
      top: 3px;
    }

    .knob-value-display {
      font-weight: bold;
      font-size: 0.7em;
      color: #000080;
      text-align: center;
      min-height: 1.2em;
      line-height: 1.1em;
      word-wrap: break-word;
      max-width: 100%;
      margin: 0;
    }

    .file-name-display {
      font-weight: normal;
      color: #333;
      font-size: 0.7em;
      display: block;
      margin-top: 1px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .load-input-group {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      align-items: center;
      margin-bottom: 5px;
    }

    .load-input-group label {
      white-space: nowrap;
      font-weight: bold;
      color: #000080;
    }

    .load-input-group input[type="text"] {
      flex-grow: 1;
      min-width: 120px;
    }

    .loading-dots::after {
      content: '';
      animation: loading-dot-animation 1.5s infinite steps(3);
    }

    @keyframes loading-dot-animation {
      0% { content: '.'; }
      33% { content: '..'; }
      66% { content: '...'; }
      100% { content: '.'; }
    }

    .slot-controls-container {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 3px;
        gap: 2px;
        font-weight: normal;
        flex-wrap: wrap;
    }

    .slot-control-btn {
        width: 20px;
        height: 16px;
        border: 1px outset #fff;
        background: #e0e0e0;
        cursor: pointer;
        font-size: 10px;
        font-weight: bold;
        font-family: "MS Sans Serif", sans-serif;
        color: #000;
        text-align: center;
        line-height: 14px;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        user-select: none;
    }

    .slot-control-btn:hover {
        background: #d0d0d0;
    }

    .slot-control-btn:active {
        border: 1px inset #808080;
    }

    .slot-control-btn.solo-active {
        background: #ffff00;
        border: 1px inset #808080;
        color: #000080;
    }

    .slot-control-btn.mute-active {
        background: #ff8080;
        border: 1px inset #808080;
        color: #800000;
    }

    #hiddenFileInputs {
      display: none;
    }

    .knob-container {
        text-align: center;
        padding: 5px;
        margin-top: var(--spacing-unit);
        margin-bottom: calc(var(--spacing-unit) * 1.5);
    }

    .knob {
        width: 40px;
        height: 40px;
        margin: 0 auto 5px;
        position: relative;
        background: linear-gradient(135deg, #dfdfdf 0%, #c0c0c0 50%, #a0a0a0 100%);
        border-radius: 50%;
        border-top: 1px solid #404040;
        border-left: 1px solid #404040;
        border-right: 1px solid #dfdfdf;
        border-bottom: 1px solid #dfdfdf;
        cursor: grab;
        user-select: none;
        box-shadow: inset 1px 1px 1px rgba(255,255,255,0.5),
                    inset -1px -1px 1px rgba(0,0,0,0.3);
    }

    .knob-face {
        width: 36px;
        height: 36px;
        background: linear-gradient(135deg, #e8e8e8 0%, #c0c0c0 50%, #808080 100%);
        border-radius: 50%;
        position: absolute;
        top: 2px;
        left: 2px;
        border-top: 1px solid #dfdfdf;
        border-left: 1px solid #dfdfdf;
        border-right: 1px solid #808080;
        border-bottom: 1px solid #808080;
    }

    .knob-indicator {
        width: 2px;
        height: 12px;
        background: #000000;
        position: absolute;
        top: 3px;
        left: 50%;
        transform-origin: bottom center;
        transform: translateX(-50%) rotate(0deg);
        border-radius: 1px;
        box-shadow: 0 0 1px rgba(255,255,255,0.5);
    }

    .knob-center {
        width: 6px;
        height: 6px;
        background: linear-gradient(135deg, #a0a0a0, #808080);
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-top: 1px solid #404040;
        border-left: 1px solid #404040;
        border-right: 1px solid #c0c0c0;
        border-bottom: 1px solid #c0c0c0;
    }

    .knob.locked {
        background: linear-gradient(135deg, #ff8080 0%, #cc6060 50%, #aa4040 100%);
        border-top: 1px solid #804040;
        border-left: 1px solid #804040;
        border-right: 1px solid #ffb0b0;
        border-bottom: 1px solid #ffb0b0;
        cursor: grab;
        box-shadow: inset 1px 1px 1px rgba(255,255,255,0.3),
                    inset -1px -1px 1px rgba(0,0,0,0.5),
                    0 0 4px rgba(255, 0, 0, 0.3);
    }

    .knob.locked .knob-face {
        background: linear-gradient(135deg, #ffaaaa 0%, #cc6060 50%, #808080 100%);
        border-top: 1px solid #ffb0b0;
        border-left: 1px solid #ffb0b0;
        border-right: 1px solid #604040;
        border-bottom: 1px solid #604040;
    }

    .knob.locked .knob-indicator {
        background: #ffffff;
        box-shadow: 0 0 2px rgba(255,255,255,0.8);
    }

    .knob.locked .knob-center {
        background: linear-gradient(135deg, #ff6060, #cc4040);
        border-top: 1px solid #cc4040;
        border-left: 1px solid #cc4040;
        border-right: 1px solid #ff8080;
        border-bottom: 1px solid #ff8080;
    }

    .util-buttons-container {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        align-items: center;
        margin-top: 10px;
    }

    .util-buttons-container button {
        margin: 0;
        margin-bottom: 5px;
    }

    .spectrum-analyzer-container {
      background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 100%);
      border: 2px inset #808080;
      padding: 10px;
      margin: 10px auto;
      border-radius: 3px;
      position: relative;
      overflow: hidden;
      width: 500px;
      display: flex;
      gap: 15px;
      align-items: center;
    }

    .spectrum-display-area {
      flex: 1;
    }

    .spectrum-analyzer-canvas {
      width: 300px;
      height: 120px;
      background: #000;
      border: 1px solid #333;
      display: block;
      border-radius: 2px;
      margin: 0 auto;
    }

    .led-meters-container {
      display: flex;
      gap: 8px;
      align-items: center;
      height: 120px;
    }

    .led-meter {
      display: flex;
      flex-direction: column-reverse;
      height: 120px;
      width: 12px;
      background: #000;
      border: 1px solid #333;
      border-radius: 2px;
      padding: 2px;
      gap: 1px;
    }

    .led-meter-label {
      color: #ccc;
      font-size: 0.7em;
      text-align: center;
      font-family: 'Courier New', monospace;
      margin-bottom: 3px;
      text-shadow: 0 0 2px #00ff00;
    }

    .led-segment {
      width: 8px;
      height: 3px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 1px;
      transition: background-color 0.05s ease;
    }

    .led-segment.green { background: #00ff00; box-shadow: 0 0 2px #00ff00; }
    .led-segment.yellow { background: #ffff00; box-shadow: 0 0 2px #ffff00; }
    .led-segment.orange { background: #ff8000; box-shadow: 0 0 2px #ff8000; }
    .led-segment.red { background: #ff0000; box-shadow: 0 0 2px #ff0000; }

    .spectrum-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 8px;
      font-size: 0.8em;
      color: #ccc;
    }

    .spectrum-mode-selector {
      display: flex;
      gap: 5px;
    }

    .spectrum-mode-btn {
      background: #2a2a2a;
      border: 1px solid #555;
      color: #ccc;
      padding: 3px 8px;
      cursor: pointer;
      font-size: 0.7em;
      border-radius: 2px;
      transition: all 0.2s;
    }

    .spectrum-mode-btn.active {
      background: #0080ff;
      color: white;
      border-color: #0080ff;
    }

    .spectrum-mode-btn:hover {
      background: #3a3a3a;
    }

    .spectrum-info {
      font-family: 'Courier New', monospace;
      font-size: 0.7em;
      color: #00ff00;
      text-shadow: 0 0 3px #00ff00;
    }

    .winamp-display {
      background: #000;
      border: 1px inset #666;
      padding: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.8em;
      color: #00ff00;
      text-align: center;
      margin-bottom: 5px;
      letter-spacing: 1px;
      text-shadow: 0 0 2px #00ff00;
    }

    .frequency-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 3px;
      font-size: 0.6em;
      color: #666;
      font-family: 'Courier New', monospace;
    }

    @media (max-width: 600px) {
        .slot-matrix {
            grid-template-columns: auto 1fr 1fr;
            gap: 1px 2px;
        }
        .slot-matrix .header-cell {
            grid-column: span 3;
            text-align: left;
        }
        .slot-matrix .label-cell {
            text-align: left;
            font-size: 0.7em;
            padding-right: 2px;
        }
        .slot-matrix .control-cell {
            padding: 1px;
        }
        .matrix-knob {
            padding: 1px;
        }
        .matrix-knob .knob {
            width: 30px;
            height: 30px;
            margin-bottom: 1px;
        }
        .matrix-knob .knob-face {
            width: 26px;
            height: 26px;
        }
        .matrix-knob .knob-indicator {
            height: 8px;
        }
        .knob-value-display {
            font-size: 0.6em;
            min-height: 1em;
            line-height: 1em;
        }
        .waveform-display-container {
            flex-direction: column;
            align-items: center;
        }
        .waveform-canvas {
            max-width: 90%;
        }
        .sequencer-row {
            justify-content: flex-start;
        }
        .spectrum-analyzer-canvas {
            height: 80px;
        }
        
        .spectrum-analyzer-container {
            width: 350px;
            flex-direction: column;
            gap: 10px;
        }
        
        .led-meters-container {
            height: 60px;
            justify-content: center;
        }
        
        .led-meter {
            height: 60px;
        }
        .util-buttons-container {
            flex-direction: column;
            align-items: stretch;
        }
        .util-buttons-container button {
            width: 100%;
        }
        
        .layout-toggle {
            display: none;
        }
        
        .panel-group.draggable {
            position: relative !important;
            width: 100% !important;
            max-width: 100% !important;
            left: auto !important;
            top: auto !important;
            transform: none !important;
        }
        
        .layout-container.free-layout {
            height: auto;
            width: 100%;
            padding: var(--spacing-unit);
        }
        
        .resize-handle {
            display: none !important;
        }
    }
  </style>
</head>
<body>
  <h2>üéß Multigrain Player - Enhanced Random Controls</h2>

  <button id="layoutToggle" class="layout-toggle">üìê FREE LAYOUT</button>
  <button id="autoArrangeBtn" class="auto-arrange-btn">‚ö° AUTO</button>

  <div id="performanceMonitor" class="performance-monitor">
    <div class="perf-title-bar">
      <div style="display: flex; align-items: center;">
        <span class="perf-title-icon"></span>
        System Monitor
      </div>
      <div class="perf-minimize-btn">_</div>
    </div>
    <div class="perf-content">
      <div class="perf-section">
        <div class="perf-section-title">System Resources</div>
        <div class="meter-row">
          <span class="meter-label">CPU Usage:</span>
          <span id="cpuUsage" class="meter-value">0%</span>
          <div class="meter-bar">
            <div id="cpuBar" class="meter-fill" style="width: 0%"></div>
          </div>
        </div>
        <div class="meter-row">
          <span class="meter-label">Memory:</span>
          <span id="memoryUsage" class="meter-value">0MB</span>
          <div class="meter-bar">
            <div id="memoryBar" class="meter-fill" style="width: 0%"></div>
          </div>
        </div>
        <div class="meter-row">
          <span class="meter-label">FPS:</span>
          <span id="fpsCounter" class="meter-value">60</span>
          <div class="meter-bar">
            <div id="fpsBar" class="meter-fill" style="width: 100%"></div>
          </div>
        </div>
      </div>
      <div class="perf-section">
        <div class="perf-section-title">Audio Engine</div>
        <div class="meter-row">
          <span class="meter-label">Voices:</span>
          <span id="activeVoices" class="meter-value">0/128</span>
          <div class="meter-bar">
            <div id="voicesBar" class="meter-fill" style="width: 0%"></div>
          </div>
        </div>
        <div class="meter-row">
          <span class="meter-label">Audio State:</span>
          <span id="audioState" class="meter-value">suspended</span>
          <span id="audioIndicator" class="status-indicator status-suspended"></span>
        </div>
      </div>
    </div>
  </div>

  <div id="layoutContainer" class="layout-container">
    <div id="controls"></div>
    <div id="utilSectionContainer"></div>
    <div id="ctrlSection"></div>
    <div id="sequencers"></div>
    <div id="outputSection"></div>
  </div>

  <div id="hiddenFileInputs">
    <input type="file" id="hiddenFileInput-slot0" accept=".wav,.mp3" data-slot="0">
    <input type="file" id="hiddenFileInput-slot1" accept=".wav,.mp3" data-slot="1">
    <input type="file" id="hiddenFileInput-slot2" accept=".wav,.mp3" data-slot="2">
    <input type="file" id="hiddenFileInput-slot3" accept=".wav,.mp3" data-slot="3">
  </div>

  <script>
    class WinAMPSpectrumAnalyzer {
        constructor(canvasElement, analyserNode) {
            this.canvas = canvasElement;
            this.ctx = canvasElement.getContext('2d');
            this.analyser = analyserNode;
            
            this.analyser.fftSize = 512;
            this.analyser.smoothingTimeConstant = 0.8;
            this.bufferLength = this.analyser.frequencyBinCount;
            this.dataArray = new Uint8Array(this.bufferLength);
            
            this.barCount = 32;
            this.mode = 'bars';
            this.isAnimating = false;
            
            this.peakValues = new Array(this.barCount).fill(0);
            this.peakFallSpeed = 2;
            
            this.frequencyRanges = this.calculateFrequencyRanges();
            
            this.setupCanvas();
        }
        
        setupCanvas() {
            const rect = this.canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            this.canvas.width = rect.width * dpr;
            this.canvas.height = rect.height * dpr;
            
            this.ctx.scale(dpr, dpr);
            this.canvas.style.width = rect.width + 'px';
            this.canvas.style.height = rect.height + 'px';
            
            this.width = rect.width;
            this.height = rect.height;
            this.barWidth = this.width / this.barCount;
        }
        
        calculateFrequencyRanges() {
            const ranges = [];
            const nyquist = 22050;
            const logMin = Math.log10(80);
            const logMax = Math.log10(nyquist);
            
            for (let i = 0; i < this.barCount; i++) {
                const logFreq = logMin + (logMax - logMin) * (i / (this.barCount - 1));
                const freq = Math.pow(10, logFreq);
                const binIndex = Math.round((freq / nyquist) * this.bufferLength);
                ranges.push(Math.min(binIndex, this.bufferLength - 1));
            }
            
            return ranges;
        }
        
        start() {
            if (!this.isAnimating) {
                this.isAnimating = true;
                this.animate();
            }
        }
        
        stop() {
            this.isAnimating = false;
            this.clearCanvas();
        }
        
        animate() {
            if (!this.isAnimating) return;
            
            this.analyser.getByteFrequencyData(this.dataArray);
            this.draw();
            
            requestAnimationFrame(() => this.animate());
        }
        
        draw() {
            this.clearCanvas();
            
            if (this.mode === 'bars') {
                this.drawBars();
            } else {
                this.drawLine();
            }
        }
        
        clearCanvas() {
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(0, 0, this.width, this.height);
            
            this.ctx.strokeStyle = '#111';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            
            for (let i = 1; i < 4; i++) {
                const y = (this.height / 4) * i;
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.width, y);
            }
            
            for (let i = 1; i < this.barCount; i++) {
                const x = this.barWidth * i;
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, this.height);
            }
            
            this.ctx.stroke();
        }
        
        drawBars() {
            for (let i = 0; i < this.barCount; i++) {
                const binIndex = this.frequencyRanges[i];
                const value = this.dataArray[binIndex] || 0;
                const normalizedValue = value / 255;
                const barHeight = normalizedValue * this.height;
                
                const x = i * this.barWidth;
                const y = this.height - barHeight;
                
                const gradient = this.ctx.createLinearGradient(0, this.height, 0, 0);
                
                if (normalizedValue > 0.8) {
                    gradient.addColorStop(0, '#00ff00');
                    gradient.addColorStop(0.6, '#ffff00');
                    gradient.addColorStop(1, '#ff0000');
                } else if (normalizedValue > 0.4) {
                    gradient.addColorStop(0, '#00ff00');
                    gradient.addColorStop(1, '#ffff00');
                } else {
                    gradient.addColorStop(0, '#008000');
                    gradient.addColorStop(1, '#00ff00');
                }
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(x + 1, y, this.barWidth - 2, barHeight);
                
                if (normalizedValue > this.peakValues[i]) {
                    this.peakValues[i] = normalizedValue;
                } else {
                    this.peakValues[i] = Math.max(0, this.peakValues[i] - this.peakFallSpeed / 60);
                }
                
                const peakY = this.height - (this.peakValues[i] * this.height);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(x + 1, peakY - 1, this.barWidth - 2, 2);
            }
        }
        
        drawLine() {
            this.ctx.strokeStyle = '#00ff00';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            
            for (let i = 0; i < this.barCount; i++) {
                const binIndex = this.frequencyRanges[i];
                const value = this.dataArray[binIndex] || 0;
                const normalizedValue = value / 255;
                
                const x = (i / (this.barCount - 1)) * this.width;
                const y = this.height - (normalizedValue * this.height);
                
                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
            
            this.ctx.stroke();
        }
        
        setMode(mode) {
            this.mode = mode;
        }
        
        getFrequencyAtBar(barIndex) {
            const nyquist = 22050;
            const logMin = Math.log10(80);
            const logMax = Math.log10(nyquist);
            const logFreq = logMin + (logMax - logMin) * (barIndex / (this.barCount - 1));
            return Math.round(Math.pow(10, logFreq));
        }
        
        getPeakFrequency() {
            let maxValue = 0;
            let maxIndex = 0;
            
            for (let i = 0; i < this.barCount; i++) {
                const binIndex = this.frequencyRanges[i];
                const value = this.dataArray[binIndex] || 0;
                
                if (value > maxValue) {
                    maxValue = value;
                    maxIndex = i;
                }
            }
            
            return this.getFrequencyAtBar(maxIndex);
        }
        
        getRMSLevel() {
            let sum = 0;
            for (let i = 0; i < this.dataArray.length; i++) {
                sum += (this.dataArray[i] / 255) ** 2;
            }
            return Math.sqrt(sum / this.dataArray.length);
        }
    }

    class OptimizedGrainVoiceManager {
        constructor(audioContext, maxVoices = 128) {
            this.audioContext = audioContext;
            this.maxVoices = maxVoices;
            this.activeVoices = new Set();
            this.voicePool = [];
            this.cleanupQueue = [];
            this.lastCleanup = 0;
            
            this.masterGain = audioContext.createGain();
            this.masterGain.gain.value = 1.0;
            
            this.stereoSplitter = audioContext.createChannelSplitter(2);
            
            this.leftAnalyser = audioContext.createAnalyser();
            this.rightAnalyser = audioContext.createAnalyser();
            
            [this.leftAnalyser, this.rightAnalyser].forEach(analyser => {
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.1;
                analyser.minDecibels = -90;
                analyser.maxDecibels = -10;
            });
            
            this.masterGain.connect(this.stereoSplitter);
            this.stereoSplitter.connect(this.leftAnalyser, 0);
            this.stereoSplitter.connect(this.rightAnalyser, 1);
            
            this.masterGain.connect(audioContext.destination);
            
            this.analyser = audioContext.createAnalyser();
            this.analyser.fftSize = 512;
            this.analyser.smoothingTimeConstant = 0.8;
            this.masterGain.connect(this.analyser);
            
            this.nodePool = {
                gainNodes: [],
                filterNodes: [],
                pannerNodes: []
            };
            
            this.preAllocateNodes();
        }

        getLeftAnalyser() {
            return this.leftAnalyser;
        }

        getRightAnalyser() {
            return this.rightAnalyser;
        }

        getLEDAnalyser() {
            return this.leftAnalyser;
        }

        preAllocateNodes() {
            for (let i = 0; i < this.maxVoices; i++) {
                this.nodePool.gainNodes.push(this.audioContext.createGain());
                this.nodePool.filterNodes.push(this.audioContext.createBiquadFilter());
                this.nodePool.pannerNodes.push(this.audioContext.createStereoPanner());
            }
        }

        getPooledNodes() {
            return {
                gainNode: this.nodePool.gainNodes.pop() || this.audioContext.createGain(),
                filterNode: this.nodePool.filterNodes.pop() || this.audioContext.createBiquadFilter(),
                pannerNode: this.nodePool.pannerNodes.pop() || this.audioContext.createStereoPanner()
            };
        }

        returnNodesToPool(nodes) {
            nodes.gainNode.gain.cancelScheduledValues(0);
            nodes.gainNode.gain.value = 1;
            nodes.gainNode.disconnect();
            
            nodes.filterNode.frequency.cancelScheduledValues(0);
            nodes.filterNode.frequency.value = 350;
            nodes.filterNode.disconnect();
            
            nodes.pannerNode.pan.cancelScheduledValues(0);
            nodes.pannerNode.pan.value = 0;
            nodes.pannerNode.disconnect();
            
            this.nodePool.gainNodes.push(nodes.gainNode);
            this.nodePool.filterNodes.push(nodes.filterNode);
            this.nodePool.pannerNodes.push(nodes.pannerNode);
        }

        createGrain(buffer, params, startTime, duration, position) {
            const now = this.audioContext.currentTime;
            
            if (++this.lastCleanup % 60 === 0) {
                this.performCleanup();
            }

            if (this.activeVoices.size >= this.maxVoices) {
                this.forceCleanupOldest();
            }

            const grain = this.createOptimizedGrain(buffer, params, startTime, duration, position);
            if (grain) {
                this.activeVoices.add(grain);
                this.scheduleCleanup(grain, startTime + duration + 0.1);
            }
            
            return grain;
        }

        createOptimizedGrain(buffer, params, startTime, duration, position) {
            try {
                const source = this.audioContext.createBufferSource();
                source.buffer = buffer;
                source.playbackRate.value = params.playbackRate;

                const nodes = this.getPooledNodes();
                
                nodes.filterNode.type = 'highpass';
                nodes.filterNode.frequency.value = params.cutoffFreq;
                
                const randomAmount = params.panRandom || 0;
                const panValue = Math.max(-1, Math.min(1, 
                    params.panControl + (Math.random() - 0.5) * randomAmount));
                nodes.pannerNode.pan.value = panValue;

                this.applyOptimizedEnvelope(nodes.gainNode, startTime, duration, params);

                source
                    .connect(nodes.filterNode)
                    .connect(nodes.pannerNode)
                    .connect(nodes.gainNode)
                    .connect(this.masterGain);

                source.start(startTime, position, duration);

                const grain = {
                    source,
                    nodes,
                    endTime: startTime + duration,
                    isActive: true
                };

                source.onended = () => {
                    this.cleanupGrain(grain);
                };

                return grain;

            } catch (error) {
                console.warn('Grain creation failed:', error);
                return null;
            }
        }

        applyOptimizedEnvelope(gainNode, startTime, duration, params) {
            const attackTime = Math.min(duration * 0.3, params.attackTime / 1000);
            const releaseTime = Math.min(duration * 0.7, params.decayTime / 1000);
            const sustainTime = Math.max(0, duration - attackTime - releaseTime);
            const baseGain = 0.2;
            const peakGain = baseGain * (params.volume || 0.7);

            gainNode.gain.setValueAtTime(0, startTime);
            
            const envelopeType = parseInt(params.envelopeShape);
            
            switch (envelopeType) {
                case 0:
                    gainNode.gain.linearRampToValueAtTime(peakGain, startTime + attackTime);
                    if (sustainTime > 0) {
                        gainNode.gain.setValueAtTime(peakGain, startTime + attackTime + sustainTime);
                    }
                    gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
                    break;
                    
                case 1:
                    gainNode.gain.exponentialRampToValueAtTime(peakGain, startTime + attackTime);
                    if (sustainTime > 0) {
                        gainNode.gain.setValueAtTime(peakGain, startTime + attackTime + sustainTime);
                    }
                    gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                    break;
                    
                case 2:
                    this.applyLogarithmicEnvelope(gainNode, startTime, attackTime, sustainTime, duration, peakGain);
                    break;
                    
                case 3:
                    this.applySigmoidEnvelope(gainNode, startTime, attackTime, sustainTime, duration, peakGain);
                    break;
                    
                case 4:
                    this.applyCosineEnvelope(gainNode, startTime, attackTime, sustainTime, duration, peakGain);
                    break;
                    
                case 5:
                    this.applyGaussianEnvelope(gainNode, startTime, duration, peakGain);
                    break;
                    
                case 6:
                    this.applyHanningEnvelope(gainNode, startTime, duration, peakGain);
                    break;
                    
                case 7:
                    this.applyTriangularEnvelope(gainNode, startTime, attackTime, sustainTime, duration, peakGain);
                    break;
                    
                default:
                    gainNode.gain.linearRampToValueAtTime(peakGain, startTime + attackTime);
                    if (sustainTime > 0) {
                        gainNode.gain.setValueAtTime(peakGain, startTime + attackTime + sustainTime);
                    }
                    gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
                    break;
            }
        }

        applyLogarithmicEnvelope(gainNode, startTime, attackTime, sustainTime, duration, peakGain) {
            const steps = 10;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const attackValue = peakGain * Math.log(1 + t * (Math.E - 1)) / Math.log(Math.E);
                gainNode.gain.linearRampToValueAtTime(attackValue, startTime + (attackTime * t));
            }
            
            if (sustainTime > 0) {
                gainNode.gain.setValueAtTime(peakGain, startTime + attackTime + sustainTime);
            }
            
            const releaseStart = startTime + attackTime + sustainTime;
            const releaseTime = duration - attackTime - sustainTime;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const releaseValue = peakGain * (1 - Math.log(1 + t * (Math.E - 1)) / Math.log(Math.E));
                gainNode.gain.linearRampToValueAtTime(releaseValue, releaseStart + (releaseTime * t));
            }
        }

        applySigmoidEnvelope(gainNode, startTime, attackTime, sustainTime, duration, peakGain) {
            const steps = 15;
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = (t - 0.5) * 12;
                const sigmoid = 1 / (1 + Math.exp(-x));
                const attackValue = peakGain * sigmoid;
                gainNode.gain.linearRampToValueAtTime(attackValue, startTime + (attackTime * t));
            }
            
            if (sustainTime > 0) {
                gainNode.gain.setValueAtTime(peakGain, startTime + attackTime + sustainTime);
            }
            
            const releaseStart = startTime + attackTime + sustainTime;
            const releaseTime = duration - attackTime - sustainTime;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = (0.5 - t) * 12;
                const sigmoid = 1 / (1 + Math.exp(-x));
                const releaseValue = peakGain * sigmoid;
                gainNode.gain.linearRampToValueAtTime(releaseValue, releaseStart + (releaseTime * t));
            }
        }

        applyCosineEnvelope(gainNode, startTime, attackTime, sustainTime, duration, peakGain) {
            const steps = 12;
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const angle = t * Math.PI / 2;
                const attackValue = peakGain * Math.sin(angle);
                gainNode.gain.linearRampToValueAtTime(attackValue, startTime + (attackTime * t));
            }
            
            if (sustainTime > 0) {
                gainNode.gain.setValueAtTime(peakGain, startTime + attackTime + sustainTime);
            }
            
            const releaseStart = startTime + attackTime + sustainTime;
            const releaseTime = duration - attackTime - sustainTime;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const angle = Math.PI / 2 + t * Math.PI / 2;
                const releaseValue = peakGain * Math.abs(Math.sin(angle));
                gainNode.gain.linearRampToValueAtTime(releaseValue, releaseStart + (releaseTime * t));
            }
        }

        applyGaussianEnvelope(gainNode, startTime, duration, peakGain) {
            const steps = 20;
            const sigma = duration / 6;
            const center = duration / 2;
            
            for (let i = 0; i <= steps; i++) {
                const t = (i / steps) * duration;
                const x = t - center;
                const gaussian = Math.exp(-(x * x) / (2 * sigma * sigma));
                const value = peakGain * gaussian;
                gainNode.gain.linearRampToValueAtTime(value, startTime + t);
            }
        }

        applyHanningEnvelope(gainNode, startTime, duration, peakGain) {
            const steps = 16;
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const hanning = 0.5 * (1 - Math.cos(2 * Math.PI * t));
                const value = peakGain * hanning;
                gainNode.gain.linearRampToValueAtTime(value, startTime + (duration * t));
            }
        }

        applyTriangularEnvelope(gainNode, startTime, attackTime, sustainTime, duration, peakGain) {
            gainNode.gain.linearRampToValueAtTime(peakGain, startTime + attackTime);
            
            if (sustainTime > 0) {
                gainNode.gain.setValueAtTime(peakGain, startTime + attackTime + sustainTime);
            }
            
            gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
        }

        scheduleCleanup(grain, cleanupTime) {
            this.cleanupQueue.push({ grain, time: cleanupTime });
        }

        performCleanup() {
            const now = this.audioContext.currentTime;
            const toCleanup = [];

            for (let i = this.cleanupQueue.length - 1; i >= 0; i--) {
                const item = this.cleanupQueue[i];
                if (item.time <= now) {
                    toCleanup.push(item.grain);
                    this.cleanupQueue.splice(i, 1);
                }
            }

            toCleanup.forEach(grain => this.cleanupGrain(grain));
        }

        forceCleanupOldest() {
            let oldestGrain = null;
            let oldestTime = Infinity;

            for (const grain of this.activeVoices) {
                if (grain.endTime < oldestTime) {
                    oldestTime = grain.endTime;
                    oldestGrain = grain;
                }
            }

            if (oldestGrain) {
                this.cleanupGrain(oldestGrain);
            }
        }

        cleanupGrain(grain) {
            if (!grain.isActive) return;

            grain.isActive = false;
            this.activeVoices.delete(grain);

            try {
                if (grain.source) {
                    grain.source.stop();
                    grain.source.disconnect();
                }
            } catch (e) {
                // Already stopped
            }

            if (grain.nodes) {
                this.returnNodesToPool(grain.nodes);
            }
        }

        stopAll() {
            for (const grain of this.activeVoices) {
                this.cleanupGrain(grain);
            }
            this.cleanupQueue.length = 0;
        }

        getActiveVoiceCount() {
            return this.activeVoices.size;
        }
        
        getAnalyser() {
            return this.analyser;
        }
        
        setMasterVolume(volume) {
            this.masterGain.gain.value = volume;
        }
    }

    class PerformanceMonitor {
        constructor() {
            this.isVisible = true;
            this.frameCount = 0;
            this.lastTime = performance.now();
            this.fps = 60;
            this.cpuUsage = 0;
            this.memoryUsage = 0;
            
            this.elements = {
                monitor: document.getElementById('performanceMonitor'),
                cpuUsage: document.getElementById('cpuUsage'),
                cpuBar: document.getElementById('cpuBar'),
                activeVoices: document.getElementById('activeVoices'),
                voicesBar: document.getElementById('voicesBar'),
                memoryUsage: document.getElementById('memoryUsage'),
                memoryBar: document.getElementById('memoryBar'),
                audioState: document.getElementById('audioState'),
                audioIndicator: document.getElementById('audioIndicator'),
                fpsCounter: document.getElementById('fpsCounter'),
                fpsBar: document.getElementById('fpsBar')
            };

            this.bindEvents();
            this.startMonitoring();
            
            setTimeout(() => {
                this.updateDisplay();
                this.updateVoiceCount(0, 128);
                this.updateAudioState('suspended');
            }, 100);
        }

        bindEvents() {
            const minimizeBtn = this.elements.monitor.querySelector('.perf-minimize-btn');
            minimizeBtn.addEventListener('click', () => this.toggle());
        }

        startMonitoring() {
            this.monitor();
        }

        monitor() {
            const now = performance.now();
            this.frameCount++;

            if (now - this.lastTime >= 500) {
                this.fps = Math.round((this.frameCount * 2000) / (now - this.lastTime));
                this.frameCount = 0;
                this.lastTime = now;
                this.updateDisplay();
            }

            requestAnimationFrame(() => this.monitor());
        }

        updateDisplay() {
            if (!this.isVisible) return;

            const baseCpuUsage = Math.max(0, Math.min(100, 100 - this.fps * 1.67));
            this.cpuUsage = baseCpuUsage + Math.random() * 10;
            this.elements.cpuUsage.textContent = `${Math.round(this.cpuUsage)}%`;
            this.elements.cpuUsage.className = 'meter-value ' + (this.cpuUsage > 70 ? 'warning' : this.cpuUsage > 90 ? 'error' : '');
            this.elements.cpuBar.style.width = `${Math.min(100, this.cpuUsage)}%`;

            this.elements.fpsCounter.textContent = this.fps;
            this.elements.fpsCounter.className = 'meter-value ' + (this.fps < 50 ? 'warning' : this.fps < 30 ? 'error' : '');
            this.elements.fpsBar.style.width = `${Math.min(100, (this.fps / 60) * 100)}%`;

            if (performance.memory) {
                const used = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                this.memoryUsage = used;
                this.elements.memoryUsage.textContent = `${used}MB`;
                this.elements.memoryUsage.className = 'meter-value ' + (used > 100 ? 'warning' : used > 200 ? 'error' : '');
                const memoryPercent = Math.min(100, (used / Math.max(100, 50)) * 100);
                this.elements.memoryBar.style.width = `${memoryPercent}%`;
            } else {
                this.memoryUsage = 20 + Math.random() * 30;
                this.elements.memoryUsage.textContent = `${Math.round(this.memoryUsage)}MB`;
                this.elements.memoryUsage.className = 'meter-value';
                this.elements.memoryBar.style.width = `${Math.min(100, (this.memoryUsage / 100) * 100)}%`;
            }
        }

        updateVoiceCount(active, max) {
            if (!this.isVisible) return;
            
            this.elements.activeVoices.textContent = `${active}/${max}`;
            this.elements.activeVoices.className = 'meter-value ' + (active > max * 0.8 ? 'warning' : active >= max ? 'error' : '');
            
            const voicePercent = Math.min(100, (active / max) * 100);
            this.elements.voicesBar.style.width = `${voicePercent}%`;
        }

        updateAudioState(state) {
            if (!this.isVisible) return;
            
            this.elements.audioState.textContent = state.toUpperCase();
            this.elements.audioState.className = 'meter-value ' + (state !== 'running' ? 'warning' : '');
            
            this.elements.audioIndicator.className = 'status-indicator ' + 
                (state === 'running' ? 'status-running' : 
                 state === 'suspended' ? 'status-suspended' : 'status-error');
        }

        toggle() {
            this.isVisible = !this.isVisible;
            this.elements.monitor.classList.toggle('hidden', !this.isVisible);
        }
    }

    class OptimizedWaveformRenderer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.offscreenCanvas = document.createElement('canvas');
            this.offscreenCtx = this.offscreenCanvas.getContext('2d');
            this.offscreenCanvas.width = canvas.width;
            this.offscreenCanvas.height = canvas.height;
            this.lastBuffer = null;
            this.cachedWaveform = null;
        }

        drawWaveform(buffer) {
            if (buffer === this.lastBuffer && this.cachedWaveform) {
                this.ctx.putImageData(this.cachedWaveform, 0, 0);
                return;
            }

            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if (!buffer) return;

            const data = buffer.getChannelData(0);
            const width = this.canvas.width;
            const height = this.canvas.height;
            const step = Math.max(1, Math.floor(data.length / width));
            const amp = height / 2;

            this.offscreenCtx.clearRect(0, 0, width, height);
            this.offscreenCtx.strokeStyle = '#0f0';
            this.offscreenCtx.lineWidth = 1;
            this.offscreenCtx.beginPath();

            for (let i = 0; i < width; i++) {
                const sampleIndex = i * step;
                const y = amp + data[sampleIndex] * amp;
                if (i === 0) {
                    this.offscreenCtx.moveTo(i, y);
                } else {
                    this.offscreenCtx.lineTo(i, y);
                }
            }

            this.offscreenCtx.stroke();
            this.cachedWaveform = this.offscreenCtx.getImageData(0, 0, width, height);
            this.lastBuffer = buffer;
            this.ctx.putImageData(this.cachedWaveform, 0, 0);
        }

        drawPlayhead(buffer, positionSec) {
            if (this.cachedWaveform) {
                this.ctx.putImageData(this.cachedWaveform, 0, 0);
            } else {
                this.drawWaveform(buffer);
            }

            if (!buffer) return;

            const x = (positionSec / buffer.duration) * this.canvas.width;
            this.ctx.strokeStyle = 'red';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
        }

        invalidateCache() {
            this.lastBuffer = null;
            this.cachedWaveform = null;
        }
    }

    class OptimizedMultigrainPlayer {
        constructor() {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.grainVoiceManager = new OptimizedGrainVoiceManager(this.audioContext, 128);
            this.performanceMonitor = new PerformanceMonitor();
            this.spectrumAnalyzer = null;
            
            this.config = {
                SLOTS: 4,
                SEQUENCER_STEPS: 16,
                GRANULAR_INTERVAL_DIVISOR: 4,
                WAVEFORM_CANVAS_WIDTH: 250,
                WAVEFORM_CANVAS_HEIGHT: 100,
                MIN_BPM: 40,
                MAX_BPM: 240,
                BPM_SENSITIVITY: 0.5,
                MIN_RANDOM_DENSITY: 0,
                MAX_RANDOM_DENSITY: 100,
                RANDOM_DENSITY_SENSITIVITY: 0.5,
                MAX_HISTORY_STATES: 50,
                PER_SLOT_CONTROL_SPECS: [
                  { label: 'S.Pos (%):', type: 'knob', id: 'startOffset', min: 0, max: 100, value: 0, step: 1 },
                  { label: 'PB Rate:', type: 'knob', id: 'playbackRate', min: 0.1, max: 2.0, step: 0.01, value: 1.0 },
                  { label: 'HPF Freq (Hz):', type: 'knob', id: 'cutoffFreq', min: 0, max: 12000, value: 100, step: 10 },
                  { label: 'Atk Time (ms):', type: 'knob', id: 'attackTime', min: 3, max: 500, value: 3, step: 1 },
                  { label: 'Dec Time (ms):', type: 'knob', id: 'decayTime', min: 5, max: 1000, value: 200, step: 1 },
                  { label: 'Env Shape:', type: 'knob', id: 'envelopeShape', min: 0, max: 7, value: 0, step: 1 },
                  { label: 'G Size (ms):', type: 'knob', id: 'grainSize', min: 10, max: 1000, value: 350, step: 10 },
                  { label: 'G PerStep:', type: 'knob', id: 'grainsPerStep', min: 1, max: 50, value: 10, step: 1 },
                  { label: 'G Voices:', type: 'knob', id: 'grainVoices', min: 1, max: 8, value: 4, step: 1 },
                  { label: 'LFO WF:', type: 'knob', id: 'lfoWaveform', min: 0, max: 3, value: 0, step: 1 },
                  { label: 'LFO Rate (Hz):', type: 'knob', id: 'lfoRate', min: 0.1, max: 5.0, step: 0.01, value: 0.5 },
                  { label: 'Spread:', type: 'knob', id: 'spread', min: 0, max: 100, value: 0, step: 1 },
                  { label: 'Pan:', type: 'knob', id: 'panControl', min: -1, max: 1, step: 0.01, value: 0 },
                  { label: 'Pan Random:', type: 'knob', id: 'panRandom', min: 0, max: 0.5, step: 0.01, value: 0.1 },
                  { label: 'Volume:', type: 'knob', id: 'volume', min: 0, max: 1.0, step: 0.01, value: 0.7 }
                ],
                GLOBAL_CONTROL_SPECS: [
                  {
                    label: 'Slot Mode:', type: 'select', id: 'slotMode',
                    options: ['Fixed (Slot 1)', 'Fixed (Slot 2)', 'Fixed (Slot 3)', 'Fixed (Slot 4)', 'All', 'Random'], selected: 4
                  },
                ],
                RANDOM_DENSITY_SPEC: { label: 'RND SEQ Density:', type: 'knob', id: 'randomDensity', min: 0, max: 100, value: 50, tooltip: '„É©„É≥„ÉÄ„É†„Ç∑„Éº„Ç±„É≥„ÇπÁîüÊàêÊôÇ„ÅÆ„Çπ„ÉÜ„ÉÉ„ÉóONÁ¢∫Áéá' },
                BPM_SPEC: { label: 'Tempo (BPM):', type: 'knob', id: 'bpm', min: 40, max: 240, value: 120, tooltip: '„Ç∑„Éº„Ç±„É≥„Çµ„Éº„ÅÆ„ÉÜ„É≥„ÉùÈÄüÂ∫¶' },
            };

            this.state = {
                audioBuffers: Array(this.config.SLOTS).fill(null),
                waveformRenderers: [],
                sequencerPatterns: Array.from({ length: this.config.SLOTS }, () => Array(this.config.SEQUENCER_STEPS).fill(true)),
                slotSoloStatus: Array(this.config.SLOTS).fill(false),
                slotMuteStatus: Array(this.config.SLOTS).fill(false),
                previewSources: Array(this.config.SLOTS).fill(null),
                isPlaying: false,
                lfoStartTime: 0,
                currentSequencerStep: 0,
                sequencerIntervalId: null,
                tempoBpm: 120,
                history: [],
                historyIndex: -1,
                knobDragStates: {},
                knobLockStates: {},
                selectedStep: 0,
                selectedSlot: 0,
                multiSelectStart: -1,
                multiSelectEnd: -1,
                isMultiSelecting: false,
                isFreeLayoutMode: false,
                sectionPositions: {},
                isMKeyPressed: false,
                isOKeyPressed: false,
                autoScalingActive: false,
                baseViewportSize: { width: 0, height: 0 },
                dragState: {
                    isDragging: false,
                    currentElement: null,
                    startX: 0,
                    startY: 0,
                    offsetX: 0,
                    offsetY: 0
                },
                resizeState: {
                    isResizing: false,
                    currentElement: null,
                    startX: 0,
                    startY: 0,
                    startWidth: 0,
                    startHeight: 0
                }
            };

            this.ui = {};
        }

        init() {
            this._createUI();
            this._bindEvents();
            this._updateBpmKnob(this.state.tempoBpm);
            this._updateRandomDensityKnob(this.config.RANDOM_DENSITY_SPEC.value);
            this._updateAllSlotControlButtons();
            this.saveCurrentState();
            
            setTimeout(() => {
                this._updateSequencerSelection();
            }, 100);
            
            this.startPerformanceTracking();
            
            window.addEventListener('beforeunload', () => {
                this._stopAutoScaling();
            });
        }

        startPerformanceTracking() {
            const updatePerformance = () => {
                const activeVoices = this.grainVoiceManager.getActiveVoiceCount();
                this.performanceMonitor.updateVoiceCount(activeVoices, 128);
                this.performanceMonitor.updateAudioState(this.audioContext.state);
                requestAnimationFrame(updatePerformance);
            };
            updatePerformance();
        }

        _createUI() {
            this._createControls();
            this._createUtilSection();
            this._createCtrlSection();
            this._createSequencer();
            this._createOutputSection();
            this._setupCollapsibleHeaders();
        }

        _createControls() {
            const controlsContainer = document.getElementById('controls');

            const modeGroup = this._createPanelGroup('MODE:', 'mode-content');
            this.config.GLOBAL_CONTROL_SPECS.forEach(spec => {
                modeGroup.content.appendChild(this._createControlElement(spec));
            });
            controlsContainer.appendChild(modeGroup.group);
            
            modeGroup.content.classList.add('collapsed-content');
            const indicator = modeGroup.title.querySelector('.indicator');
            if (indicator) {
                indicator.textContent = '+';
            }

            const mainGroup = this._createPanelGroup('MAIN:', 'main-content');
            const waveformDisplayContainer = document.createElement('div');
            waveformDisplayContainer.className = 'waveform-display-container';

            for (let s = 0; s < this.config.SLOTS; s++) {
                const canvas = document.createElement('canvas');
                canvas.id = `waveform-${s}`;
                canvas.width = this.config.WAVEFORM_CANVAS_WIDTH;
                canvas.height = this.config.WAVEFORM_CANVAS_HEIGHT;
                canvas.className = 'waveform-canvas';
                waveformDisplayContainer.appendChild(canvas);
                
                this.state.waveformRenderers.push(new OptimizedWaveformRenderer(canvas));
            }
            mainGroup.content.appendChild(waveformDisplayContainer);
            controlsContainer.appendChild(mainGroup.group);
        }

        _createCtrlSection() {
            const ctrlContainer = document.getElementById('ctrlSection');
            const ctrlGroup = this._createPanelGroup('CTRL:', 'ctrl-content');

            const slotMatrixContainer = this._createSlotMatrix(ctrlGroup.content);
            
            const emptyCell = document.createElement('div');
            emptyCell.className = 'label-cell';
            slotMatrixContainer.appendChild(emptyCell);
            
            this.config.PER_SLOT_CONTROL_SPECS.forEach((spec, index) => {
                const headerCell = document.createElement('div');
                headerCell.className = 'param-header-cell';
                
                // ÂÖ®„Å¶„ÅÆ„Éë„É©„É°„Éº„Çø„Å´R„ÄÅL„ÄÅ0„Éú„Çø„É≥„ÇíËøΩÂä†
                headerCell.innerHTML = `
                    <div class="param-header-with-button">
                        <div class="param-header-text">${spec.label}</div>
                        <div class="param-button-group">
                            <button class="param-random-btn" data-param="${spec.id}" title="Randomize ${spec.label} for all slots"></button>
                            <button class="param-lock-btn" data-param="${spec.id}" title="Toggle lock/unlock ${spec.label} for all slots"></button>
                            <button class="param-reset-btn" data-param="${spec.id}" title="Reset ${spec.label} to default for all slots"></button>
                        </div>
                    </div>
                `;
                
                slotMatrixContainer.appendChild(headerCell);
            });
            
            for (let s = 0; s < this.config.SLOTS; s++) {
                const slotLabelCell = document.createElement('div');
                slotLabelCell.className = 'label-cell';
                slotLabelCell.dataset.slot = s;
                slotLabelCell.innerHTML = `
                    <span>Slot ${s + 1}</span>
                    <span id="fileName-slot${s}" class="file-name-display"></span>
                    <div class="slot-controls-container">
                        <button class="slot-control-btn" id="soloBtn-${s}" data-slot="${s}" data-type="solo" title="Solo">S</button>
                        <button class="slot-control-btn" id="muteBtn-${s}" data-slot="${s}" data-type="mute" title="Mute">M</button>
                    </div>
                `;
                slotMatrixContainer.appendChild(slotLabelCell);
                
                this.config.PER_SLOT_CONTROL_SPECS.forEach(spec => {
                    const controlCell = document.createElement('div');
                    controlCell.className = 'control-cell';
                    controlCell.appendChild(this._createControlElement(spec, s));
                    slotMatrixContainer.appendChild(controlCell);
                });
            }
            ctrlContainer.appendChild(ctrlGroup.group);
        }

        _createOutputSection() {
            const outputContainer = document.getElementById('outputSection');
            const outputGroup = this._createPanelGroup('OUTPUT:', 'output-content');
            
            const winampDisplay = document.createElement('div');
            winampDisplay.className = 'winamp-display';
            winampDisplay.id = 'winampDisplay';
            winampDisplay.textContent = 'MULTIGRAIN SPECTRUM ANALYZER v2.1 - ENHANCED RANDOM CONTROLS';
            outputGroup.content.appendChild(winampDisplay);
            
            const spectrumContainer = document.createElement('div');
            spectrumContainer.className = 'spectrum-analyzer-container';
            
            const spectrumDisplayArea = document.createElement('div');
            spectrumDisplayArea.className = 'spectrum-display-area';
            
            const spectrumCanvas = document.createElement('canvas');
            spectrumCanvas.className = 'spectrum-analyzer-canvas';
            spectrumCanvas.id = 'spectrumCanvas';
            spectrumDisplayArea.appendChild(spectrumCanvas);
            
            const freqLabels = document.createElement('div');
            freqLabels.className = 'frequency-labels';
            freqLabels.innerHTML = `
                <span>80Hz</span>
                <span>200Hz</span>
                <span>500Hz</span>
                <span>1kHz</span>
                <span>2kHz</span>
                <span>5kHz</span>
                <span>10kHz</span>
                <span>20kHz</span>
            `;
            spectrumDisplayArea.appendChild(freqLabels);
            
            const spectrumControls = document.createElement('div');
            spectrumControls.className = 'spectrum-controls';
            spectrumControls.innerHTML = `
                <div class="spectrum-mode-selector">
                    <button class="spectrum-mode-btn active" data-mode="bars">BARS</button>
                    <button class="spectrum-mode-btn" data-mode="line">LINE</button>
                </div>
                <div class="spectrum-info" id="spectrumInfo">
                    PEAK: 0Hz | RMS: 0%
                </div>
            `;
            spectrumDisplayArea.appendChild(spectrumControls);
            
            const ledMetersContainer = document.createElement('div');
            ledMetersContainer.className = 'led-meters-container';
            
            const leftMeterWrapper = document.createElement('div');
            leftMeterWrapper.innerHTML = `
                <div class="led-meter-label">L</div>
                <div class="led-meter" id="ledMeterLeft">
                    ${Array.from({ length: 30 }, () => '<div class="led-segment"></div>').join('')}
                </div>
            `;
            
            const rightMeterWrapper = document.createElement('div');
            rightMeterWrapper.innerHTML = `
                <div class="led-meter-label">R</div>
                <div class="led-meter" id="ledMeterRight">
                    ${Array.from({ length: 30 }, () => '<div class="led-segment"></div>').join('')}
                </div>
            `;
            
            ledMetersContainer.appendChild(leftMeterWrapper);
            ledMetersContainer.appendChild(rightMeterWrapper);
            
            spectrumContainer.appendChild(spectrumDisplayArea);
            spectrumContainer.appendChild(ledMetersContainer);
            outputGroup.content.appendChild(spectrumContainer);
            outputContainer.appendChild(outputGroup.group);
            
            setTimeout(() => {
                this.spectrumAnalyzer = new WinAMPSpectrumAnalyzer(
                    spectrumCanvas, 
                    this.grainVoiceManager.getAnalyser()
                );
                this._bindSpectrumEvents();
                this._initializeLEDMeters();
            }, 100);
        }

        _bindSpectrumEvents() {
            document.querySelectorAll('.spectrum-mode-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.spectrum-mode-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    if (this.spectrumAnalyzer) {
                        this.spectrumAnalyzer.setMode(e.target.dataset.mode);
                    }
                });
            });
            
            this._startSpectrumInfoUpdate();
        }

        _startSpectrumInfoUpdate() {
            const updateInfo = () => {
                if (this.spectrumAnalyzer && this.state.isPlaying) {
                    const peakFreq = this.spectrumAnalyzer.getPeakFrequency();
                    const rmsLevel = Math.round(this.spectrumAnalyzer.getRMSLevel() * 100);
                    
                    document.getElementById('spectrumInfo').textContent = 
                        `PEAK: ${peakFreq}Hz | RMS: ${rmsLevel}%`;
                    
                    const display = document.getElementById('winampDisplay');
                    if (rmsLevel > 0) {
                        display.textContent = `‚ô™ PLAYING - PEAK: ${peakFreq}Hz - RMS: ${rmsLevel}% - ENHANCED RANDOM CONTROLS ‚ô™`;
                    } else {
                        display.textContent = 'MULTIGRAIN SPECTRUM ANALYZER v2.1 - ENHANCED RANDOM CONTROLS';
                    }
                }
                
                setTimeout(updateInfo, 100);
            };
            updateInfo();
        }

        _initializeLEDMeters() {
            this.ledMeterState = {
                leftPeakHold: 0,
                rightPeakHold: 0,
                leftPeakHoldTime: 0,
                rightPeakHoldTime: 0,
                peakHoldDuration: 1000,
                leftSegments: document.querySelectorAll('#ledMeterLeft .led-segment'),
                rightSegments: document.querySelectorAll('#ledMeterRight .led-segment'),
                isRunning: false
            };
            
            this.leftAnalysisData = new Uint8Array(this.grainVoiceManager.getLeftAnalyser().frequencyBinCount);
            this.rightAnalysisData = new Uint8Array(this.grainVoiceManager.getRightAnalyser().frequencyBinCount);
            
            this._startLEDMeterLoop();
        }

        _startLEDMeterLoop() {
            if (this.ledMeterState.isRunning) return;
            
            this.ledMeterState.isRunning = true;
            
            const updateLEDMeters = () => {
                if (!this.ledMeterState.isRunning) return;
                
                if (this.state.isPlaying && this.grainVoiceManager.getActiveVoiceCount() > 0) {
                    this._updateTrueLRLEDDisplay();
                } else {
                    this._fadeLEDDisplay();
                }
                
                requestAnimationFrame(updateLEDMeters);
            };
            
            updateLEDMeters();
        }

        _updateTrueLRLEDDisplay() {
            const leftAnalyser = this.grainVoiceManager.getLeftAnalyser();
            const rightAnalyser = this.grainVoiceManager.getRightAnalyser();
            
            if (!leftAnalyser || !rightAnalyser) {
                return;
            }
            
            leftAnalyser.getByteFrequencyData(this.leftAnalysisData);
            rightAnalyser.getByteFrequencyData(this.rightAnalysisData);
            
            let leftSum = 0;
            for (let i = 0; i < this.leftAnalysisData.length; i++) {
                leftSum += this.leftAnalysisData[i] * this.leftAnalysisData[i];
            }
            const leftRMS = Math.sqrt(leftSum / this.leftAnalysisData.length) / 255;
            
            let rightSum = 0;
            for (let i = 0; i < this.rightAnalysisData.length; i++) {
                rightSum += this.rightAnalysisData[i] * this.rightAnalysisData[i];
            }
            const rightRMS = Math.sqrt(rightSum / this.rightAnalysisData.length) / 255;
            
            const now = Date.now();
            
            if (leftRMS > this.ledMeterState.leftPeakHold) {
                this.ledMeterState.leftPeakHold = leftRMS;
                this.ledMeterState.leftPeakHoldTime = now;
            } else if (now - this.ledMeterState.leftPeakHoldTime > this.ledMeterState.peakHoldDuration) {
                this.ledMeterState.leftPeakHold *= 0.95;
            }
            
            if (rightRMS > this.ledMeterState.rightPeakHold) {
                this.ledMeterState.rightPeakHold = rightRMS;
                this.ledMeterState.rightPeakHoldTime = now;
            } else if (now - this.ledMeterState.rightPeakHoldTime > this.ledMeterState.peakHoldDuration) {
                this.ledMeterState.rightPeakHold *= 0.95;
            }
            
            this._renderLEDChannel(this.ledMeterState.leftSegments, leftRMS, this.ledMeterState.leftPeakHold);
            this._renderLEDChannel(this.ledMeterState.rightSegments, rightRMS, this.ledMeterState.rightPeakHold);
        }

        _renderLEDChannel(segments, currentLevel, peakLevel) {
            const segmentCount = segments.length;
            const currentSegments = Math.floor(currentLevel * segmentCount);
            const peakSegment = Math.floor(peakLevel * segmentCount);
            
            segments.forEach((segment, index) => {
                segment.classList.remove('green', 'yellow', 'orange', 'red');
                
                const isCurrentLit = index < currentSegments;
                const isPeakLit = index === peakSegment && peakLevel > 0.05;
                
                if (isCurrentLit || isPeakLit) {
                    if (index < segmentCount * 0.67) {
                        segment.classList.add('green');
                    } else if (index < segmentCount * 0.83) {
                        segment.classList.add('yellow');
                    } else if (index < segmentCount * 0.93) {
                        segment.classList.add('orange');
                    } else {
                        segment.classList.add('red');
                    }
                }
            });
        }

        _fadeLEDDisplay() {
            this.ledMeterState.leftPeakHold *= 0.92;
            this.ledMeterState.rightPeakHold *= 0.92;
            
            if (this.ledMeterState.leftPeakHold < 0.01) this.ledMeterState.leftPeakHold = 0;
            if (this.ledMeterState.rightPeakHold < 0.01) this.ledMeterState.rightPeakHold = 0;
            
            this._renderLEDChannel(this.ledMeterState.leftSegments, 0, this.ledMeterState.leftPeakHold);
            this._renderLEDChannel(this.ledMeterState.rightSegments, 0, this.ledMeterState.rightPeakHold);
        }

        _createSlotMatrix(container) {
            const slotMatrixContainer = document.createElement('div');
            slotMatrixContainer.id = 'slotMatrix';
            slotMatrixContainer.className = 'slot-matrix';
            container.appendChild(slotMatrixContainer);
            return slotMatrixContainer;
        }

        _createSequencer() {
            const sequencerDiv = document.getElementById("sequencers");
            const seqGroup = this._createPanelGroup('SEQ (TRG):', 'sequencer-content');

            for (let s = 0; s < this.config.SLOTS; s++) {
                const row = document.createElement("div");
                row.className = "sequencer-row";
                for (let i = 0; i < this.config.SEQUENCER_STEPS; i++) {
                    const cell = document.createElement("div");
                    cell.className = "step active";
                    cell.textContent = i + 1;
                    cell.dataset.slot = s;
                    cell.dataset.step = i;
                    row.appendChild(cell);
                }
                seqGroup.content.appendChild(row);
            }

            // „Éé„Éñ„Ç≥„É≥„Éà„É≠„Éº„É´„ÇíËøΩÂä†
            const knobsContainer = document.createElement('div');
            knobsContainer.style.cssText = `
                display: flex;
                gap: 20px;
                justify-content: center;
                align-items: center;
                margin-top: 15px;
                padding: 10px;
                background: linear-gradient(135deg, #e8e8e8, #d0d0d0);
                border: 1px inset #808080;
                border-radius: 3px;
            `;

            const randomDensityContainer = document.createElement('div');
            randomDensityContainer.style.cssText = `text-align: center; position: relative;`;
            randomDensityContainer.appendChild(this._createControlElement(this.config.RANDOM_DENSITY_SPEC));
            
            const bpmContainer = document.createElement('div');
            bpmContainer.style.cssText = `text-align: center; position: relative;`;
            bpmContainer.appendChild(this._createControlElement(this.config.BPM_SPEC));

            knobsContainer.appendChild(randomDensityContainer);
            knobsContainer.appendChild(bpmContainer);
            seqGroup.content.appendChild(knobsContainer);

            sequencerDiv.appendChild(seqGroup.group);
        }

        _createUtilSection() {
            const container = document.getElementById('utilSectionContainer');
            const utilGroup = this._createPanelGroup('UTIL:', 'util-content');
            
            utilGroup.content.innerHTML = `
                <div class="load-input-group">
                    <label>STR:</label>
                    <input type="text" id="loadPathInput" placeholder="Filter by filename" class="form-element" value="">
                    <button id="loadPathButton">Load</button>
                </div>
            `;
            
            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'util-buttons-container';
            
            buttonsContainer.innerHTML = `
                <button id="startGranular">Start</button>
                <button id="stopGranular">Stop</button>
                <button id="randomizeSequencer" title="ÁèæÂú®„ÅÆDensityÂÄ§„Åß„É©„É≥„ÉÄ„É†„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÁîüÊàê">RND SEQ</button>
                <button id="randomizeAllSlotParams">RND PRM</button>
                <button id="clearPanButton">PAN(0)</button>
                <button id="resetHpfButton">HPF(0)</button>
                <button id="setHpf130Button">HPF(130)</button>
                <button id="setHpf900Button">HPF(900)</button>
                <button id="setAtk0Button">ATK(3)</button>
                <button id="percButton">Perc</button>
                <button id="unlockAllKnobsButton">üîì UNLOCK ALL</button>
                <button id="undoButton" disabled>UNDO</button>
                <button id="redoButton" disabled>REDO</button>
                <button id="togglePerfMonitor">PERF</button>
                <span id="loadingStatus" style="margin-left: 10px; font-weight: bold; color: #000080;"></span>
            `;
            
            utilGroup.content.appendChild(buttonsContainer);
            container.appendChild(utilGroup.group);
        }

        _createPanelGroup(titleText, contentId) {
            const group = document.createElement("div");
            group.className = "panel-group";
            
            const sectionId = titleText.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() + '-section';
            group.id = sectionId;
            
            const title = document.createElement("h3");
            title.className = "group-title collapsible-header";
            title.innerHTML = `${titleText}<span class="indicator">-</span>`;
            const content = document.createElement('div');
            content.id = contentId;
            group.appendChild(title);
            group.appendChild(content);
            return { group, title, content };
        }

        _createControlElement(spec, slotIndex = null) {
            const elementId = slotIndex !== null ? `${spec.id}-slot${slotIndex}` : spec.id;

            switch (spec.type) {
                case 'select':
                    const label = document.createElement('label');
                    label.textContent = spec.label;
                    
                    const inputElement = document.createElement('select');
                    spec.options.forEach((opt, i) => {
                        const option = document.createElement('option');
                        option.value = i;
                        option.textContent = opt;
                        if (spec.selected === i) option.selected = true;
                        inputElement.appendChild(option);
                    });
                    inputElement.addEventListener('change', () => this.saveCurrentState());
                    inputElement.id = elementId;
                    inputElement.className = 'form-element';
                    label.appendChild(inputElement);
                    return label;
                    
                case 'knob':
                    const knobContainer = document.createElement('div');
                    knobContainer.className = 'knob-container matrix-knob';
                    
                    // „ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØËøΩÂä†
                    let tooltipAttr = '';
                    if (spec.tooltip) {
                        tooltipAttr = `title="${spec.tooltip}"`;
                    }
                    
                    knobContainer.innerHTML = `
                        <div class="knob" id="${elementId}Knob" ${tooltipAttr}>
                            <div class="knob-face">
                                <div class="knob-indicator" id="${elementId}Indicator"></div>
                                <div class="knob-center"></div>
                            </div>
                        </div>
                        <div id="${elementId}ValueDisplay" class="knob-value-display">${this._formatKnobValue(spec, spec.value)}</div>`;
                    
                    setTimeout(() => {
                        this._updateKnobDisplay(elementId, spec, spec.value);
                        this._bindKnobEvents(elementId, spec, slotIndex);
                    }, 0);
                    
                    return knobContainer;
                
                default:
                    const defaultLabel = document.createElement('label');
                    defaultLabel.textContent = spec.label;
                    
                    const defaultInput = document.createElement('input');
                    defaultInput.type = 'range';
                    Object.assign(defaultInput, { min: spec.min, max: spec.max, step: spec.step || 1, value: spec.value });
                    defaultInput.id = elementId;
                    defaultInput.className = 'form-element';
                    defaultLabel.appendChild(defaultInput);
                    return defaultLabel;
            }
        }

        _formatKnobValue(spec, value) {
            if (spec.id === 'volume') {
                const percentage = Math.round(value * 100);
                const dbValue = value > 0 ? (20 * Math.log10(value)).toFixed(1) : '-‚àû';
                return `${percentage}% (${dbValue}dB)`;
            } else if (spec.id === 'playbackRate') {
                const semitones = 12 * Math.log2(value);
                const semitonesText = semitones >= 0 ? `+${semitones.toFixed(1)}` : semitones.toFixed(1);
                return `${value.toFixed(2)} (${semitonesText}st)`;
            } else if (spec.id === 'envelopeShape') {
                const shapes = ['Linear', 'Exponential', 'Logarithmic', 'S-Curve', 'Cosine', 'Gaussian', 'Hanning', 'Triangular'];
                return shapes[value] || 'Linear';
            } else if (spec.id === 'lfoWaveform') {
                const waveforms = ['Sine', 'Triangle', 'Square', 'Random'];
                return waveforms[value] || 'Sine';
            } else if (spec.id === 'panRandom') {
                const percentage = Math.round(value * 100);
                return `${percentage}% (¬±${(value * 100).toFixed(1)}%)`;
            } else if (spec.id === 'randomDensity') {
                const percentage = Math.round(value);
                return `${percentage}% SEQ PROB`;
            } else if (spec.id === 'bpm') {
                const stepIntervalMs = (60 / value) * 1000 / 4;
                return `${Math.round(value)} BPM (${stepIntervalMs.toFixed(1)}ms/step)`;
            } else {
                return parseFloat(value).toFixed(spec.step < 1 ? 2 : 0);
            }
        }

        _updateKnobDisplay(elementId, spec, value) {
            const indicator = document.getElementById(`${elementId}Indicator`);
            const display = document.getElementById(`${elementId}ValueDisplay`);
            
            if (indicator) {
                const normalizedValue = (value - spec.min) / (spec.max - spec.min);
                const angle = (normalizedValue * 270) - 135;
                indicator.style.transform = `translateX(-50%) rotate(${angle}deg)`;
            }
            
            if (display) {
                display.textContent = this._formatKnobValue(spec, value);
            }
        }

        _setKnobLocked(elementId, isLocked) {
            const knobElement = document.getElementById(`${elementId}Knob`);
            if (!knobElement) return;

            this.state.knobLockStates[elementId] = isLocked;
            
            if (isLocked) {
                knobElement.classList.add('locked');
            } else {
                knobElement.classList.remove('locked');
            }
            
            this.saveCurrentState();
        }

        _isKnobLocked(elementId) {
            return this.state.knobLockStates[elementId] || false;
        }

        _unlockAllKnobs() {
            let unlockedCount = 0;
            
            for (let s = 0; s < this.config.SLOTS; s++) {
                this.config.PER_SLOT_CONTROL_SPECS.forEach(spec => {
                    const elementId = `${spec.id}-slot${s}`;
                    if (this._isKnobLocked(elementId)) {
                        this._setKnobLocked(elementId, false);
                        unlockedCount++;
                    }
                });
            }
            
            const globalKnobs = ['bpm', 'randomDensity'];
            globalKnobs.forEach(knobId => {
                if (this._isKnobLocked(knobId)) {
                    this._setKnobLocked(knobId, false);
                    unlockedCount++;
                }
            });
            
            if (unlockedCount > 0) {
                console.log(`üîì Unlocked ${unlockedCount} knobs`);
            }
        }

        _toggleParameterLock(paramId) {
            const spec = this.config.PER_SLOT_CONTROL_SPECS.find(s => s.id === paramId);
            if (!spec) return;
            
            // ÂÖ®„Çπ„É≠„ÉÉ„Éà„ÅÆÁèæÂú®„ÅÆ„É≠„ÉÉ„ÇØÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
            const elementIds = [];
            let lockedCount = 0;
            
            for (let slot = 0; slot < this.config.SLOTS; slot++) {
                const elementId = `${paramId}-slot${slot}`;
                elementIds.push(elementId);
                if (this._isKnobLocked(elementId)) {
                    lockedCount++;
                }
            }
            
            // ÂÖ®„Å¶„É≠„ÉÉ„ÇØÊ∏à„Åø„Å™„Çâ„Ç¢„É≥„É≠„ÉÉ„ÇØ„ÄÅ„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞ÂÖ®„Å¶„É≠„ÉÉ„ÇØ
            const shouldLock = lockedCount < this.config.SLOTS;
            let changedCount = 0;
            
            elementIds.forEach(elementId => {
                const currentLockState = this._isKnobLocked(elementId);
                if (currentLockState !== shouldLock) {
                    this._setKnobLocked(elementId, shouldLock);
                    changedCount++;
                }
            });
            
            // „Éú„Çø„É≥„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞
            const button = document.querySelector(`[data-param="${paramId}"].param-lock-btn`);
            if (button) {
                if (shouldLock) {
                    button.classList.add('locked');
                } else {
                    button.classList.remove('locked');
                }
                
                // Ë¶ñË¶öÁöÑ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
                button.classList.add('flash');
                setTimeout(() => {
                    button.classList.remove('flash');
                }, 300);
            }
            
            const action = shouldLock ? 'locked' : 'unlocked';
            console.log(`üîí ${spec.label} ${action} for ${changedCount}/${this.config.SLOTS} slots`);
            
            // Áä∂ÊÖãÂ§âÊõ¥„Åå„ÅÇ„Å£„ÅüÂ†¥Âêà„ÅÆ„ÅøÂ±•Ê≠¥„Å´‰øùÂ≠ò
            if (changedCount > 0) {
                this.saveCurrentState();
            }
        }

        _resetParameter(paramId) {
            const spec = this.config.PER_SLOT_CONTROL_SPECS.find(s => s.id === paramId);
            if (!spec) return;
            
            let resetCount = 0;
            let lockedCount = 0;
            
            for (let slot = 0; slot < this.config.SLOTS; slot++) {
                const elementId = `${paramId}-slot${slot}`;
                
                if (this._isKnobLocked(elementId)) {
                    lockedCount++;
                    continue;
                }
                
                // ÂêÑ„Éë„É©„É°„Éº„Çø„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂÄ§„Å´„É™„Çª„ÉÉ„Éà
                const defaultValue = spec.value;
                
                if (this.state.knobDragStates[elementId]) {
                    this.state.knobDragStates[elementId].currentValue = defaultValue;
                }
                
                this._updateKnobDisplay(elementId, spec, defaultValue);
                resetCount++;
            }
            
            // Ë¶ñË¶öÁöÑ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
            const buttons = document.querySelectorAll(`[data-param="${paramId}"].param-reset-btn`);
            buttons.forEach(button => {
                button.classList.add('flash');
                setTimeout(() => {
                    button.classList.remove('flash');
                }, 300);
            });
            
            console.log(`üîÑ ${spec.label} reset to default (${spec.value}) for ${resetCount}/${this.config.SLOTS} slots${lockedCount > 0 ? ` (${lockedCount} locked)` : ''}`);
            this.saveCurrentState();
        }

        _randomizeParameter(paramId) {
            const spec = this.config.PER_SLOT_CONTROL_SPECS.find(s => s.id === paramId);
            if (!spec) return;
            
            let randomizedCount = 0;
            let lockedCount = 0;
            
            for (let slot = 0; slot < this.config.SLOTS; slot++) {
                const elementId = `${paramId}-slot${slot}`;
                
                if (this._isKnobLocked(elementId)) {
                    lockedCount++;
                    continue;
                }
                
                let randomValue;
                if (spec.id === 'volume') {
                    // Volume„ÅØÂ∞ë„ÅóÁâπÂà•„Å™Âá¶ÁêÜ
                    randomValue = Math.random() * 0.5 + 0.3; // 0.3-0.8„ÅÆÁØÑÂõ≤
                } else if (spec.id === 'envelopeShape' || spec.id === 'lfoWaveform') {
                    // Êï¥Êï∞ÂÄ§„ÅÆ„Éë„É©„É°„Éº„Çø
                    randomValue = Math.floor(Math.random() * (spec.max - spec.min + 1)) + spec.min;
                } else {
                    // ÈÄöÂ∏∏„ÅÆ„Éë„É©„É°„Éº„Çø
                    randomValue = Math.random() * (spec.max - spec.min) + spec.min;
                    if (spec.step) {
                        randomValue = Math.round(randomValue / spec.step) * spec.step;
                    }
                }
                
                if (this.state.knobDragStates[elementId]) {
                    this.state.knobDragStates[elementId].currentValue = randomValue;
                }
                
                this._updateKnobDisplay(elementId, spec, randomValue);
                randomizedCount++;
            }
            
            // Ë¶ñË¶öÁöÑ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
            const buttons = document.querySelectorAll(`[data-param="${paramId}"]`);
            buttons.forEach(button => {
                button.classList.add('flash');
                setTimeout(() => {
                    button.classList.remove('flash');
                }, 300);
            });
            
            console.log(`üé≤ ${spec.label} randomized for ${randomizedCount}/${this.config.SLOTS} slots${lockedCount > 0 ? ` (${lockedCount} locked)` : ''}`);
            this.saveCurrentState();
        }

        _bindKnobEvents(elementId, spec, slotIndex) {
            const knobElement = document.getElementById(`${elementId}Knob`);
            if (!knobElement) return;

            this.state.knobDragStates[elementId] = {
                isDragging: false,
                startY: 0,
                startValue: spec.value,
                currentValue: spec.value,
                lastTapTime: 0
            };

            const valueRange = spec.max - spec.min;
            const baseSensitivity = 0.5;
            const baseRange = 100;
            const normalizedSensitivity = baseSensitivity * (valueRange / baseRange);

            const onDragStart = (clientY) => {
                this.state.knobDragStates[elementId].isDragging = true;
                knobElement.style.cursor = 'ns-resize';
                this.state.knobDragStates[elementId].startY = clientY;
                this.state.knobDragStates[elementId].startValue = this.state.knobDragStates[elementId].currentValue;
                return true;
            };

            const onDragMove = (clientY) => {
                const dragState = this.state.knobDragStates[elementId];
                if (!dragState.isDragging) return;

                const deltaY = dragState.startY - clientY;
                let newValue = dragState.startValue + (deltaY * normalizedSensitivity);
                
                newValue = Math.max(spec.min, Math.min(spec.max, newValue));
                
                if (spec.step) {
                    newValue = Math.round(newValue / spec.step) * spec.step;
                }
                
                dragState.currentValue = newValue;
                this._updateKnobDisplay(elementId, spec, newValue);
            };

            const onDragEnd = () => {
                const dragState = this.state.knobDragStates[elementId];
                if (dragState.isDragging) {
                    dragState.isDragging = false;
                    knobElement.style.cursor = 'grab';
                    this.saveCurrentState();
                }
            };

            const onDoubleAction = () => {
                const dragState = this.state.knobDragStates[elementId];
                dragState.currentValue = spec.value;
                this._updateKnobDisplay(elementId, spec, spec.value);
                this.saveCurrentState();
                
                knobElement.style.transition = 'transform 0.1s ease';
                knobElement.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    knobElement.style.transform = 'scale(1)';
                    setTimeout(() => {
                        knobElement.style.transition = '';
                    }, 100);
                }, 100);
            };

            const onRightClick = (e) => {
                e.preventDefault();
                const isCurrentlyLocked = this._isKnobLocked(elementId);
                this._setKnobLocked(elementId, !isCurrentlyLocked);
            };

            knobElement.addEventListener('mousedown', e => { 
                if (e.button === 0) {
                    onDragStart(e.clientY); 
                    e.preventDefault(); 
                }
            });
            
            knobElement.addEventListener('contextmenu', onRightClick);
            
            document.addEventListener('mousemove', e => onDragMove(e.clientY));
            document.addEventListener('mouseup', () => onDragEnd());

            knobElement.addEventListener('dblclick', e => {
                e.preventDefault();
                onDoubleAction();
            });

            knobElement.addEventListener('touchstart', e => {
                const currentTime = Date.now();
                const dragState = this.state.knobDragStates[elementId];
                
                if (currentTime - dragState.lastTapTime < 300) {
                    e.preventDefault();
                    onDoubleAction();
                    dragState.lastTapTime = 0;
                    return;
                }
                
                dragState.lastTapTime = currentTime;
                onDragStart(e.touches[0].clientY); 
                e.preventDefault(); 
            }, { passive: false });

            document.addEventListener('touchmove', e => { 
                onDragMove(e.touches[0].clientY); 
                e.preventDefault(); 
            }, { passive: false });
            
            document.addEventListener('touchend', () => onDragEnd());
            document.addEventListener('touchcancel', () => onDragEnd());
            
            if (this._isKnobLocked(elementId)) {
                knobElement.classList.add('locked');
            }
            knobElement.style.cursor = 'grab';
        }

        _getKnobValue(elementId) {
            const dragState = this.state.knobDragStates[elementId];
            return dragState ? dragState.currentValue : 0;
        }

        _setupCollapsibleHeaders() {
            document.querySelectorAll('.collapsible-header').forEach(header => {
                header.addEventListener('click', () => {
                    if (this.state.isFreeLayoutMode || header.classList.contains('no-collapse')) {
                        return;
                    }
                    
                    const content = header.nextElementSibling;
                    const indicator = header.querySelector('.indicator');
                    if (content && indicator) {
                        content.classList.toggle('collapsed-content');
                        indicator.textContent = content.classList.contains('collapsed-content') ? '+' : '-';
                        this.saveCurrentState();
                    }
                });
            });
        }

        _bindEvents() {
            this.ui = {
                startGranular: document.getElementById('startGranular'),
                stopGranular: document.getElementById('stopGranular'),
                randomizeSequencer: document.getElementById('randomizeSequencer'),
                randomizeAllSlotParams: document.getElementById('randomizeAllSlotParams'),
                clearPanButton: document.getElementById('clearPanButton'),
                resetHpfButton: document.getElementById('resetHpfButton'),
                setHpf130Button: document.getElementById('setHpf130Button'),
                setHpf900Button: document.getElementById('setHpf900Button'),
                setAtk0Button: document.getElementById('setAtk0Button'),
                percButton: document.getElementById('percButton'),
                unlockAllKnobsButton: document.getElementById('unlockAllKnobsButton'),
                undoButton: document.getElementById('undoButton'),
                redoButton: document.getElementById('redoButton'),
                loadingStatus: document.getElementById('loadingStatus'),
                bpmKnob: document.getElementById('bpmKnob'),
                randomDensityKnob: document.getElementById('randomDensityKnob'),
                loadPathButton: document.getElementById('loadPathButton'),
                sequencerContainer: document.getElementById('sequencer-content'),
                slotMatrix: document.getElementById('slotMatrix'),
                togglePerfMonitor: document.getElementById('togglePerfMonitor'),
            };

            this.ui.startGranular.addEventListener('click', () => this.startGranularPlayback());
            this.ui.stopGranular.addEventListener('click', () => this.stopGranularPlayback());
            this.ui.randomizeSequencer.addEventListener('click', () => this.randomizeSequencer());
            this.ui.randomizeAllSlotParams.addEventListener('click', () => this.randomizeAllSlotParams());
            this.ui.clearPanButton.addEventListener('click', () => this.clearAllPan());
            this.ui.resetHpfButton.addEventListener('click', () => this.setHpf(0));
            this.ui.setHpf130Button.addEventListener('click', () => this.setHpf(130));
            this.ui.setHpf900Button.addEventListener('click', () => this.setHpf(900));
            this.ui.setAtk0Button.addEventListener('click', () => this.setAttackTime(3));
            this.ui.percButton.addEventListener('click', () => this.setPercussivePreset());
            this.ui.unlockAllKnobsButton.addEventListener('click', () => this._unlockAllKnobs());
            this.ui.undoButton.addEventListener('click', () => this.undo());
            this.ui.redoButton.addEventListener('click', () => this.redo());
            this.ui.loadPathButton.addEventListener('click', () => this._loadFolderSamples());
            this.ui.togglePerfMonitor.addEventListener('click', () => this.performanceMonitor.toggle());

            // „Éë„É©„É°„Éº„ÇøÂà•„ÅÆ„É©„É≥„ÉÄ„Éû„Ç§„Ç∫„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('param-random-btn')) {
                    const paramId = e.target.dataset.param;
                    this._randomizeParameter(paramId);
                }
                
                if (e.target.classList.contains('param-reset-btn')) {
                    const paramId = e.target.dataset.param;
                    this._resetParameter(paramId);
                }
                
                if (e.target.classList.contains('param-lock-btn')) {
                    const paramId = e.target.dataset.param;
                    this._toggleParameterLock(paramId);
                }
            });

            for (let s = 0; s < this.config.SLOTS; s++) {
                document.getElementById(`hiddenFileInput-slot${s}`).addEventListener('change', e => this._handleFileLoad(e));
                const canvas = document.getElementById(`waveform-${s}`);
                canvas.addEventListener('mousedown', (e) => this._onWaveformPlaybackStart(e, s));
                canvas.addEventListener('mouseup', (e) => this._onWaveformPlaybackStop(e, s));
                canvas.addEventListener('mouseleave', (e) => this._onWaveformPlaybackStop(e, s));
                canvas.addEventListener('touchstart', (e) => this._onWaveformPlaybackStart(e, s), { passive: false });
                canvas.addEventListener('touchend', (e) => this._onWaveformPlaybackStop(e, s));
                canvas.addEventListener('touchcancel', (e) => this._onWaveformPlaybackStop(e, s));
            }

            this.ui.sequencerContainer.addEventListener('click', e => {
                if (e.target.classList.contains('step')) this._handleStepClick(e.target);
            });
            this.ui.slotMatrix.addEventListener('click', e => {
                 const slotLabel = e.target.closest('[data-slot]');
                 if (slotLabel && !e.target.closest('.slot-controls-container')) {
                     const slot = slotLabel.dataset.slot;
                     if (slot !== undefined) {
                         document.getElementById(`hiddenFileInput-slot${slot}`).click();
                     }
                 }
                 if (e.target.classList.contains('slot-control-btn')) {
                     this._handleSlotControlClick(e.target);
                 }
            });

            this._bindKnobEvents('bpm', this.config.BPM_SPEC, null);
            this._bindKnobEvents('randomDensity', this.config.RANDOM_DENSITY_SPEC, null);
            
            this._bindKeyboardShortcuts();
            this._initializeDragAndDrop();
        }

        _initializeDragAndDrop() {
            const layoutToggle = document.getElementById('layoutToggle');
            const autoArrangeBtn = document.getElementById('autoArrangeBtn');
            
            layoutToggle.addEventListener('click', () => this._toggleLayoutMode());
            autoArrangeBtn.addEventListener('click', () => this._autoArrangePanels());
            
            this._setupSectionDragging();
        }

        _toggleLayoutMode() {
            this.state.isFreeLayoutMode = !this.state.isFreeLayoutMode;
            const layoutContainer = document.getElementById('layoutContainer');
            const layoutToggle = document.getElementById('layoutToggle');
            const autoArrangeBtn = document.getElementById('autoArrangeBtn');
            
            if (this.state.isFreeLayoutMode) {
                layoutContainer.classList.add('free-layout');
                layoutToggle.textContent = 'üìê NORMAL LAYOUT';
                autoArrangeBtn.classList.add('show');
                this._enableFreeLayout();
                console.log('üéõÔ∏è Switched to FREE LAYOUT mode with auto-scaling');
            } else {
                layoutContainer.classList.remove('free-layout');
                layoutToggle.textContent = 'üìê FREE LAYOUT';
                autoArrangeBtn.classList.remove('show');
                this._disableFreeLayout();
                console.log('üéõÔ∏è Switched to NORMAL LAYOUT mode');
            }
        }

        _autoArrangePanels() {
            if (!this.state.isFreeLayoutMode) return;
            
            const sections = document.querySelectorAll('.panel-group.draggable');
            if (sections.length === 0) return;
            
            // „Éì„É•„Éº„Éù„Éº„Éà„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const margin = 20;
            const headerHeight = 120;
            
            // ÂêÑ„Éë„Éç„É´„ÅÆÁèæÂú®„ÅÆ„Çµ„Ç§„Ç∫„Å®‰ΩçÁΩÆ„ÇíÂèñÂæó
            const panels = Array.from(sections).map(section => {
                const rect = section.getBoundingClientRect();
                const currentLeft = parseInt(section.style.left) || rect.left;
                const currentTop = parseInt(section.style.top) || rect.top;
                
                return {
                    element: section,
                    originalX: currentLeft,
                    originalY: currentTop,
                    width: rect.width,
                    height: rect.height,
                    newX: currentLeft,
                    newY: currentTop
                };
            });
            
            console.log(`üìê Auto-arrange: Organizing ${panels.length} panels while keeping their sizes`);
            
            // ÁèæÂú®„ÅÆ‰ΩçÁΩÆ„Å´Ëøë„ÅÑÈ†Ü„Åß„ÇΩ„Éº„Éà
            panels.sort((a, b) => {
                const distA = Math.sqrt(a.originalX * a.originalX + a.originalY * a.originalY);
                const distB = Math.sqrt(b.originalX * b.originalX + b.originalY * b.originalY);
                return distA - distB;
            });
            
            // Êó¢„Å´ÈÖçÁΩÆ„Åï„Çå„Åü„Éë„Éç„É´„ÅÆÈ†òÂüü„ÇíË®òÈå≤
            const occupiedAreas = [];
            
            panels.forEach((panel, index) => {
                // ÁêÜÊÉ≥ÁöÑ„Å™‰ΩçÁΩÆ„ÇíÁèæÂú®‰ΩçÁΩÆ„ÅÆËøë„Åè„ÅßÊé¢„Åô
                const idealPosition = this._findNearestNonOverlappingPosition(
                    panel.originalX,
                    panel.originalY,
                    panel.width,
                    panel.height,
                    occupiedAreas,
                    viewportWidth,
                    viewportHeight,
                    margin,
                    headerHeight
                );
                
                panel.newX = idealPosition.x;
                panel.newY = idealPosition.y;
                
                // ÈÖçÁΩÆÊ∏à„ÅøÈ†òÂüü„Å´ËøΩÂä†
                occupiedAreas.push({
                    x: idealPosition.x,
                    y: idealPosition.y,
                    width: panel.width,
                    height: panel.height
                });
                
                // „Éë„Éç„É´„ÅÆÂ§âÂΩ¢„Çí„É™„Çª„ÉÉ„Éà
                const section = panel.element;
                section.style.transform = '';
                section.style.transformOrigin = '';
                
                // „Çπ„Ç±„Éº„É´Ë°®Á§∫„ÇíÂâäÈô§
                const scaleIndicator = section.querySelector('.scale-indicator');
                if (scaleIndicator) {
                    scaleIndicator.remove();
                }
                
                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥‰ªò„Åç„ÅßÈÖçÁΩÆÔºà„Çµ„Ç§„Ç∫„ÅØÂ§âÊõ¥„Åó„Å™„ÅÑÔºâ
                section.style.transition = 'all 0.3s ease';
                section.style.left = idealPosition.x + 'px';
                section.style.top = idealPosition.y + 'px';
                // width „Å® height „ÅØÂ§âÊõ¥„Åó„Å™„ÅÑ
                
                // ‰ΩçÁΩÆ„Çí‰øùÂ≠òÔºà„Çµ„Ç§„Ç∫„ÅØÁèæÂú®„ÅÆ„Åæ„ÅæÔºâ
                this.state.sectionPositions[section.id] = {
                    x: idealPosition.x,
                    y: idealPosition.y,
                    width: panel.width,
                    height: panel.height
                };
                
                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÁµÇ‰∫ÜÂæå„Å´transition„ÇíÂâäÈô§
                setTimeout(() => {
                    section.style.transition = '';
                }, 300);
            });
            
            console.log('‚ö° Auto-arranged all panels to nearest non-overlapping positions');
        }

        _findNearestNonOverlappingPosition(targetX, targetY, width, height, occupiedAreas, viewportWidth, viewportHeight, margin, headerHeight) {
            const searchRadius = 80; // Êé¢Á¥¢ÂçäÂæÑ„ÇíÊã°Â§ß
            const step = 15; // Êé¢Á¥¢„Çπ„ÉÜ„ÉÉ„Éó„ÇíÁ¥∞„Åã„Åè
            
            // ÊúÄÂ§ßÊúâÂäπÁØÑÂõ≤
            const maxX = viewportWidth - width - margin;
            const maxY = viewportHeight - height - margin;
            const minX = margin;
            const minY = headerHeight;
            
            // ÁèæÂú®‰ΩçÁΩÆ„ÅåÊúâÂäπÁØÑÂõ≤ÂÜÖ„ÅßÈáçË§á„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®
            const clampedX = Math.max(minX, Math.min(maxX, targetX));
            const clampedY = Math.max(minY, Math.min(maxY, targetY));
            
            if (!this._hasOverlap(clampedX, clampedY, width, height, occupiedAreas)) {
                return { x: clampedX, y: clampedY };
            }
            
            // Ëû∫ÊóãÁä∂„Å´Ëøë„ÅÑ‰ΩçÁΩÆ„ÇíÊé¢Á¥¢
            for (let radius = step; radius <= searchRadius * 4; radius += step) {
                const positions = this._generateSearchPositions(clampedX, clampedY, radius, step);
                
                for (const pos of positions) {
                    const x = Math.max(minX, Math.min(maxX, pos.x));
                    const y = Math.max(minY, Math.min(maxY, pos.y));
                    
                    if (!this._hasOverlap(x, y, width, height, occupiedAreas)) {
                        return { x, y };
                    }
                }
            }
            
            // „Åù„Çå„Åß„ÇÇË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ„Ç∞„É™„ÉÉ„ÉâÁä∂„Å´ÂÖ®ÁØÑÂõ≤„ÇíÊé¢„Åô
            for (let y = minY; y <= maxY; y += step) {
                for (let x = minX; x <= maxX; x += step) {
                    if (!this._hasOverlap(x, y, width, height, occupiedAreas)) {
                        return { x, y };
                    }
                }
            }
            
            // ÊúÄÂæå„ÅÆÊâãÊÆµÔºöÂè≥‰∏ãÊñπÂêë„Å´„Åö„Çâ„Åó„Å¶Âº∑Âà∂ÈÖçÁΩÆ
            let fallbackX = Math.min(maxX, clampedX + 50);
            let fallbackY = Math.min(maxY, clampedY + 50);
            
            // „Åù„Çå„Åß„ÇÇÈáçË§á„Åô„ÇãÂ†¥Âêà„ÅØ‰∏ã„Å´„Åö„Çâ„Åô
            while (fallbackY <= maxY && this._hasOverlap(fallbackX, fallbackY, width, height, occupiedAreas)) {
                fallbackY += 30;
            }
            
            return { x: fallbackX, y: Math.min(maxY, fallbackY) };
        }

        _generateSearchPositions(centerX, centerY, radius, step) {
            const positions = [];
            const steps = Math.max(8, Math.floor(2 * Math.PI * radius / step));
            
            for (let i = 0; i < steps; i++) {
                const angle = (2 * Math.PI * i) / steps;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                positions.push({ x: Math.round(x), y: Math.round(y) });
            }
            
            return positions;
        }

        _hasOverlap(x, y, width, height, occupiedAreas) {
            const buffer = 15; // ÈáçË§áÂà§ÂÆö„ÅÆ„Éê„ÉÉ„Éï„Ç°„ÇíÂ¢óÂä†
            
            return occupiedAreas.some(area => {
                // „Çà„ÇäÂé≥ÂØÜ„Å™ÈáçË§áÂà§ÂÆö
                const overlap = !(
                    x >= area.x + area.width + buffer ||  // Âè≥ÂÅ¥„Å´ÂÆåÂÖ®„Å´Èõ¢„Çå„Å¶„ÅÑ„Çã
                    x + width + buffer <= area.x ||       // Â∑¶ÂÅ¥„Å´ÂÆåÂÖ®„Å´Èõ¢„Çå„Å¶„ÅÑ„Çã
                    y >= area.y + area.height + buffer || // ‰∏ãÂÅ¥„Å´ÂÆåÂÖ®„Å´Èõ¢„Çå„Å¶„ÅÑ„Çã
                    y + height + buffer <= area.y         // ‰∏äÂÅ¥„Å´ÂÆåÂÖ®„Å´Èõ¢„Çå„Å¶„ÅÑ„Çã
                );
                
                return overlap;
            });
        }

        _enableFreeLayout() {
            const sections = document.querySelectorAll('.panel-group');
            sections.forEach((section, index) => {
                section.classList.add('draggable');
                
                const existingHandle = section.querySelector('.resize-handle');
                if (existingHandle) {
                    existingHandle.remove();
                }
                
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                resizeHandle.dataset.sectionId = section.id;
                resizeHandle.setAttribute('title', 'Drag to resize');
                section.appendChild(resizeHandle);
                
                const titleHeader = section.querySelector('.group-title');
                if (titleHeader) {
                    titleHeader.classList.add('no-collapse');
                    const indicator = titleHeader.querySelector('.indicator');
                    if (indicator) {
                        indicator.style.display = 'none';
                    }
                }
                
                const content = section.querySelector('[id$="-content"]');
                if (content && content.classList.contains('collapsed-content')) {
                    content.classList.remove('collapsed-content');
                }
                
                const savedPosition = this.state.sectionPositions[section.id];
                if (savedPosition) {
                    section.style.left = savedPosition.x + 'px';
                    section.style.top = savedPosition.y + 'px';
                    section.style.width = savedPosition.width + 'px';
                    if (savedPosition.height) {
                        section.style.height = savedPosition.height + 'px';
                    }
                } else {
                    const col = index % 2;
                    const row = Math.floor(index / 2);
                    
                    let defaultWidth = '300px';
                    if (section.id === 'main-section') {
                        defaultWidth = '580px';
                    } else if (section.id === 'ctrl-section') {
                        defaultWidth = '900px';
                    } else if (section.id === 'output-section') {
                        defaultWidth = '600px';
                    }
                    
                    section.style.left = (col * 620 + 20) + 'px';
                    section.style.top = (row * 280 + 100) + 'px';
                    section.style.width = defaultWidth;
                    section.style.minHeight = '150px';
                }
            });
        }

        _disableFreeLayout() {
            const sections = document.querySelectorAll('.panel-group');
            sections.forEach(section => {
                this.state.sectionPositions[section.id] = {
                    x: parseInt(section.style.left) || 0,
                    y: parseInt(section.style.top) || 0,
                    width: parseInt(section.style.width) || 300,
                    height: parseInt(section.style.height) || 'auto'
                };
                
                const resizeHandle = section.querySelector('.resize-handle');
                if (resizeHandle) {
                    resizeHandle.remove();
                }
                
                const titleHeader = section.querySelector('.group-title');
                if (titleHeader) {
                    titleHeader.classList.remove('no-collapse');
                    const indicator = titleHeader.querySelector('.indicator');
                    if (indicator) {
                        indicator.style.display = '';
                    }
                }
                
                section.classList.remove('draggable', 'dragging', 'resizing');
                section.style.left = '';
                section.style.top = '';
                section.style.width = '';
                section.style.height = '';
                section.style.position = '';
                section.style.transform = '';
                section.style.transformOrigin = '';
                
                const scaleIndicator = section.querySelector('.scale-indicator');
                if (scaleIndicator) {
                    scaleIndicator.remove();
                }
                
                const scaledElements = section.querySelectorAll('[style*="transform"]');
                scaledElements.forEach(el => {
                    if (el.style.transform.includes('scale')) {
                        el.style.transform = '';
                        el.style.transformOrigin = '';
                    }
                });
            });
            
            this._stopAutoScaling();
        }

        _startAutoScaling() {
            if (this.state.autoScalingActive) return;
            
            this.state.autoScalingActive = true;
            this.state.baseViewportSize = {
                width: window.innerWidth,
                height: window.innerHeight
            };
            
            this._adjustSectionsToViewport();
            
            this._resizeListener = () => {
                if (this.state.isFreeLayoutMode && this.state.autoScalingActive) {
                    this._adjustSectionsToViewport();
                    
                    if (this.spectrumAnalyzer) {
                        setTimeout(() => {
                            this.spectrumAnalyzer.setupCanvas();
                        }, 100);
                    }
                }
            };
            
            window.addEventListener('resize', this._resizeListener);
            console.log('üîÑ Auto-scaling started for FREE LAYOUT mode');
        }

        _stopAutoScaling() {
            if (!this.state.autoScalingActive) return;
            
            this.state.autoScalingActive = false;
            
            if (this._resizeListener) {
                window.removeEventListener('resize', this._resizeListener);
                this._resizeListener = null;
            }
            
            console.log('üîÑ Auto-scaling stopped');
        }

        _adjustSectionsToViewport() {
            if (this.state.dragState.isDragging || this.state.resizeState.isResizing) {
                return;
            }
            
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const sections = document.querySelectorAll('.panel-group.draggable');
            
            if (sections.length === 0) return;
            
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                const currentLeft = parseInt(section.style.left) || 0;
                const currentTop = parseInt(section.style.top) || 0;
                const currentWidth = parseInt(section.style.width) || 300;
                const currentHeight = parseInt(section.style.height) || 200;
                
                let newLeft = currentLeft;
                let newTop = currentTop;
                let newWidth = currentWidth;
                let newHeight = currentHeight;
                let scale = 1;
                
                if (currentLeft + currentWidth > viewportWidth - 40) {
                    const maxWidth = viewportWidth - currentLeft - 40;
                    if (maxWidth > 200) {
                        newWidth = maxWidth;
                    } else {
                        newLeft = Math.max(20, viewportWidth - currentWidth - 40);
                        if (newLeft < 20) {
                            newLeft = 20;
                            newWidth = viewportWidth - 60;
                        }
                    }
                }
                
                if (currentTop + currentHeight > viewportHeight - 40) {
                    const maxHeight = viewportHeight - currentTop - 40;
                    if (maxHeight > 150) {
                        newHeight = maxHeight;
                    } else {
                        newTop = Math.max(20, viewportHeight - currentHeight - 40);
                        if (newTop < 20) {
                            newTop = 20;
                            newHeight = viewportHeight - 60;
                        }
                    }
                }
                
                const minScale = 0.5;
                const maxSectionWidth = viewportWidth * 0.9;
                const maxSectionHeight = viewportHeight * 0.9;
                
                if (newWidth > maxSectionWidth) {
                    scale = Math.min(scale, maxSectionWidth / newWidth);
                }
                if (newHeight > maxSectionHeight) {
                    scale = Math.min(scale, maxSectionHeight / newHeight);
                }
                
                scale = Math.max(minScale, scale);
                
                section.style.left = newLeft + 'px';
                section.style.top = newTop + 'px';
                section.style.width = newWidth + 'px';
                section.style.height = newHeight + 'px';
                
                if (scale < 1) {
                    section.style.transform = `scale(${scale})`;
                    section.style.transformOrigin = 'top left';
                    section.style.zIndex = '999';
                    
                    const scaleIndicator = section.querySelector('.scale-indicator') || document.createElement('div');
                    if (!section.querySelector('.scale-indicator')) {
                        scaleIndicator.className = 'scale-indicator';
                        scaleIndicator.style.cssText = `
                            position: absolute;
                            top: -20px;
                            right: 5px;
                            background: rgba(255, 165, 0, 0.9);
                            color: white;
                            padding: 2px 6px;
                            font-size: 0.7em;
                            font-weight: bold;
                            border-radius: 3px;
                            z-index: 1003;
                            pointer-events: none;
                        `;
                        section.appendChild(scaleIndicator);
                    }
                    scaleIndicator.textContent = `${Math.round(scale * 100)}%`;
                } else {
                    section.style.transform = '';
                    section.style.transformOrigin = '';
                    
                    const scaleIndicator = section.querySelector('.scale-indicator');
                    if (scaleIndicator) {
                        scaleIndicator.remove();
                    }
                }
                
                this._scaleInternalContent(section, scale);
            });
        }

        _scaleInternalContent(section, scale) {
            const waveformCanvases = section.querySelectorAll('.waveform-canvas');
            waveformCanvases.forEach(canvas => {
                if (scale < 1) {
                    canvas.style.transform = `scale(${Math.max(0.7, scale)})`;
                    canvas.style.transformOrigin = 'top left';
                } else {
                    canvas.style.transform = '';
                    canvas.style.transformOrigin = '';
                }
            });
            
            const spectrumCanvas = section.querySelector('#spectrumCanvas');
            if (spectrumCanvas && scale < 1) {
                const spectrumContainer = section.querySelector('.spectrum-analyzer-container');
                if (spectrumContainer) {
                    spectrumContainer.style.transform = `scale(${Math.max(0.8, scale)})`;
                    spectrumContainer.style.transformOrigin = 'top left';
                }
            } else if (spectrumCanvas) {
                const spectrumContainer = section.querySelector('.spectrum-analyzer-container');
                if (spectrumContainer) {
                    spectrumContainer.style.transform = '';
                    spectrumContainer.style.transformOrigin = '';
                }
            }
            
            const matrixKnobs = section.querySelectorAll('.matrix-knob .knob');
            matrixKnobs.forEach(knob => {
                if (scale < 0.8) {
                    knob.style.transform = `scale(${Math.max(0.6, scale)})`;
                    knob.style.transformOrigin = 'center';
                } else {
                    knob.style.transform = '';
                    knob.style.transformOrigin = '';
                }
            });
        }

        _setupSectionDragging() {
            document.addEventListener('mousedown', (e) => this._handleDragResizeStart(e));
            document.addEventListener('mousemove', (e) => this._handleDragResizeMove(e));
            document.addEventListener('mouseup', (e) => this._handleDragResizeEnd(e));
            
            document.addEventListener('touchstart', (e) => this._handleDragResizeStart(e), {passive: false});
            document.addEventListener('touchmove', (e) => this._handleDragResizeMove(e), {passive: false});
            document.addEventListener('touchend', (e) => this._handleDragResizeEnd(e));
        }

        _handleDragResizeStart(e) {
            if (!this.state.isFreeLayoutMode) return;
            
            if (e.target.classList.contains('resize-handle')) {
                this._startResize(e, e.target);
                return;
            }
            
            const titleBar = e.target.closest('.group-title');
            if (!titleBar) return;
            
            const target = titleBar.closest('.panel-group');
            if (!target || !target.classList.contains('draggable')) return;
            
            this._startDrag(e, target, titleBar);
        }

        _handleDragResizeMove(e) {
            if (this.state.dragState.isDragging) {
                this._handleDragMove(e);
            } else if (this.state.resizeState.isResizing) {
                this._handleResizeMove(e);
            }
        }

        _handleDragResizeEnd(e) {
            if (this.state.dragState.isDragging) {
                this._handleDragEnd(e);
            } else if (this.state.resizeState.isResizing) {
                this._handleResizeEnd(e);
            }
        }

        _startDrag(e, target, titleBar) {
            e.preventDefault();
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            const rect = target.getBoundingClientRect();
            
            this.state.dragState = {
                isDragging: true,
                currentElement: target,
                startX: clientX,
                startY: clientY,
                offsetX: clientX - rect.left,
                offsetY: clientY - rect.top
            };
            
            target.classList.add('dragging');
            document.body.style.userSelect = 'none';
            document.body.style.overflow = 'hidden';
        }

        _startResize(e, resizeHandle) {
            e.preventDefault();
            e.stopPropagation();
            
            const target = resizeHandle.parentElement;
            if (!target || !target.classList.contains('panel-group')) {
                return;
            }
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            const rect = target.getBoundingClientRect();
            
            this.state.resizeState = {
                isResizing: true,
                currentElement: target,
                startX: clientX,
                startY: clientY,
                startWidth: rect.width,
                startHeight: rect.height
            };
            
            target.classList.add('resizing');
            document.body.style.userSelect = 'none';
            document.body.style.cursor = 'se-resize';
        }

        _handleDragMove(e) {
            if (!this.state.dragState.isDragging) return;
            
            e.preventDefault();
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            const newX = clientX - this.state.dragState.offsetX;
            const newY = clientY - this.state.dragState.offsetY;
            
            const container = document.getElementById('layoutContainer');
            const containerRect = container.getBoundingClientRect();
            const element = this.state.dragState.currentElement;
            const elementRect = element.getBoundingClientRect();
            
            const maxX = containerRect.width - elementRect.width;
            const maxY = containerRect.height - elementRect.height;
            
            const boundedX = Math.max(0, Math.min(newX, maxX));
            const boundedY = Math.max(0, Math.min(newY, maxY));
            
            element.style.left = boundedX + 'px';
            element.style.top = boundedY + 'px';
        }

        _handleResizeMove(e) {
            if (!this.state.resizeState.isResizing) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            const deltaX = clientX - this.state.resizeState.startX;
            const deltaY = clientY - this.state.resizeState.startY;
            
            let newWidth = this.state.resizeState.startWidth + deltaX;
            let newHeight = this.state.resizeState.startHeight + deltaY;
            
            const minWidth = 200;
            const maxWidth = 1000;
            const minHeight = 150;
            const maxHeight = 1000;
            
            newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
            newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
            
            const element = this.state.resizeState.currentElement;
            element.style.width = newWidth + 'px';
            element.style.height = newHeight + 'px';
        }

        _handleDragEnd(e) {
            if (!this.state.dragState.isDragging) return;
            
            const element = this.state.dragState.currentElement;
            element.classList.remove('dragging');
            document.body.style.userSelect = '';
            document.body.style.overflow = '';
            
            this.state.sectionPositions[element.id] = {
                ...this.state.sectionPositions[element.id],
                x: parseInt(element.style.left) || 0,
                y: parseInt(element.style.top) || 0
            };
            
            this.state.dragState = {
                isDragging: false,
                currentElement: null,
                startX: 0,
                startY: 0,
                offsetX: 0,
                offsetY: 0
            };
        }

        _handleResizeEnd(e) {
            if (!this.state.resizeState.isResizing) return;
            
            const element = this.state.resizeState.currentElement;
            element.classList.remove('resizing');
            document.body.style.userSelect = '';
            document.body.style.cursor = '';
            
            const currentPosition = this.state.sectionPositions[element.id] || {};
            this.state.sectionPositions[element.id] = {
                ...currentPosition,
                width: parseInt(element.style.width) || 300,
                height: parseInt(element.style.height) || 200
            };
            
            this.state.resizeState = {
                isResizing: false,
                currentElement: null,
                startX: 0,
                startY: 0,
                startWidth: 0,
                startHeight: 0
            };
        }

        _bindKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                const activeElement = document.activeElement;
                if (activeElement && (
                    activeElement.tagName === 'INPUT' || 
                    activeElement.tagName === 'TEXTAREA' || 
                    activeElement.tagName === 'SELECT' ||
                    activeElement.contentEditable === 'true'
                )) {
                    return;
                }

                if (e.code === 'KeyM') {
                    this.state.isMKeyPressed = true;
                }
                
                if (e.code === 'KeyO') {
                    this.state.isOKeyPressed = true;
                }

                switch (e.code) {
                    case 'Space':
                        e.preventDefault();
                        this._handleSpaceKey();
                        break;
                        
                    case 'Escape':
                        e.preventDefault();
                        this._handleEscapeKey();
                        break;
                        
                    case 'KeyZ':
                        if (e.ctrlKey && !e.shiftKey) {
                            e.preventDefault();
                            this.undo();
                        }
                        break;
                        
                    case 'KeyY':
                        if (e.ctrlKey) {
                            e.preventDefault();
                            this.redo();
                        }
                        break;

                    case 'KeyL':
                        if (e.ctrlKey) {
                            e.preventDefault();
                            this._loadFolderSamples();
                        }
                        break;

                    case 'Digit1':
                        if (e.shiftKey) {
                            e.preventDefault();
                            this._handleSlotShortcut(0, 'solo');
                        } else if (this.state.isMKeyPressed && this.state.isOKeyPressed) {
                            e.preventDefault();
                            this._handleModeShortcut(0); // Fixed (Slot 1)
                        } else if (this.state.isMKeyPressed) {
                            e.preventDefault();
                            this._handleSlotShortcut(0, 'mute'); // Mute (Slot 1)
                        }
                        break;

                    case 'Digit2':
                        if (e.shiftKey) {
                            e.preventDefault();
                            this._handleSlotShortcut(1, 'solo');
                        } else if (this.state.isMKeyPressed && this.state.isOKeyPressed) {
                            e.preventDefault();
                            this._handleModeShortcut(1); // Fixed (Slot 2)
                        } else if (this.state.isMKeyPressed) {
                            e.preventDefault();
                            this._handleSlotShortcut(1, 'mute'); // Mute (Slot 2)
                        }
                        break;

                    case 'Digit3':
                        if (e.shiftKey) {
                            e.preventDefault();
                            this._handleSlotShortcut(2, 'solo');
                        } else if (this.state.isMKeyPressed && this.state.isOKeyPressed) {
                            e.preventDefault();
                            this._handleModeShortcut(2); // Fixed (Slot 3)
                        } else if (this.state.isMKeyPressed) {
                            e.preventDefault();
                            this._handleSlotShortcut(2, 'mute'); // Mute (Slot 3)
                        }
                        break;

                    case 'Digit4':
                        if (e.shiftKey) {
                            e.preventDefault();
                            this._handleSlotShortcut(3, 'solo');
                        } else if (this.state.isMKeyPressed && this.state.isOKeyPressed) {
                            e.preventDefault();
                            this._handleModeShortcut(3); // Fixed (Slot 4)
                        } else if (this.state.isMKeyPressed) {
                            e.preventDefault();
                            this._handleSlotShortcut(3, 'mute'); // Mute (Slot 4)
                        }
                        break;

                    case 'KeyA':
                        if (this.state.isMKeyPressed && this.state.isOKeyPressed) {
                            e.preventDefault();
                            this._handleModeShortcut(4); // All
                        }
                        break;

                    case 'KeyR':
                        if (this.state.isMKeyPressed && this.state.isOKeyPressed) {
                            e.preventDefault();
                            this._handleModeShortcut(5); // Random
                        }
                        break;

                    case 'ArrowLeft':
                        e.preventDefault();
                        this._handleSequencerNavigation('left', e.shiftKey);
                        break;
                        
                    case 'ArrowRight':
                        e.preventDefault();
                        this._handleSequencerNavigation('right', e.shiftKey);
                        break;
                        
                    case 'ArrowUp':
                        e.preventDefault();
                        this._handleSequencerNavigation('up', e.shiftKey);
                        break;
                        
                    case 'ArrowDown':
                        e.preventDefault();
                        this._handleSequencerNavigation('down', e.shiftKey);
                        break;
                        
                    case 'Enter':
                        e.preventDefault();
                        this._handleSequencerToggle();
                        break;
                        
                    case 'Delete':
                        e.preventDefault();
                        this._handleSequencerDelete();
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.code === 'KeyM') {
                    this.state.isMKeyPressed = false;
                }
                if (e.code === 'KeyO') {
                    this.state.isOKeyPressed = false;
                }
            });
        }

        _handleModeShortcut(modeValue) {
            const slotModeSelect = document.getElementById('slotMode');
            if (slotModeSelect) {
                slotModeSelect.value = modeValue;
                
                // Ë¶ñË¶öÁöÑ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
                const modePanel = document.getElementById('mode-section');
                if (modePanel) {
                    modePanel.style.transition = 'transform 0.1s ease';
                    modePanel.style.transform = 'scale(1.02)';
                    setTimeout(() => {
                        modePanel.style.transform = 'scale(1)';
                        setTimeout(() => {
                            modePanel.style.transition = '';
                        }, 100);
                    }, 100);
                }
                
                // „Ç≥„É≥„ÇΩ„Éº„É´„É≠„Ç∞„ÅßÁ¢∫Ë™ç
                const modeNames = [
                    'Fixed (Slot 1)', 'Fixed (Slot 2)', 'Fixed (Slot 3)', 
                    'Fixed (Slot 4)', 'All', 'Random'
                ];
                console.log(`üéõÔ∏è Mode changed to: ${modeNames[modeValue]}`);
                
                this.saveCurrentState();
            }
        }

        _handleSpaceKey() {
            if (this.state.isPlaying) {
                this.stopGranularPlayback();
            } else {
                this.startGranularPlayback();
            }
        }

        _handleSequencerNavigation(direction, isShiftPressed) {
            const maxStep = this.config.SEQUENCER_STEPS - 1;
            const maxSlot = this.config.SLOTS - 1;

            switch (direction) {
                case 'left':
                    if (isShiftPressed) {
                        this._handleMultiSelect('left');
                    } else {
                        this._clearMultiSelect();
                        this.state.selectedStep = Math.max(0, this.state.selectedStep - 1);
                    }
                    break;
                    
                case 'right':
                    if (isShiftPressed) {
                        this._handleMultiSelect('right');
                    } else {
                        this._clearMultiSelect();
                        this.state.selectedStep = Math.min(maxStep, this.state.selectedStep + 1);
                    }
                    break;
                    
                case 'up':
                    this._clearMultiSelect();
                    this.state.selectedSlot = Math.max(0, this.state.selectedSlot - 1);
                    break;
                    
                case 'down':
                    this._clearMultiSelect();
                    this.state.selectedSlot = Math.min(maxSlot, this.state.selectedSlot + 1);
                    break;
            }

            this._updateSequencerSelection();
        }

        _handleMultiSelect(direction) {
            if (!this.state.isMultiSelecting) {
                this.state.isMultiSelecting = true;
                this.state.multiSelectStart = this.state.selectedStep;
                this.state.multiSelectEnd = this.state.selectedStep;
            }

            if (direction === 'left' && this.state.multiSelectEnd > 0) {
                this.state.multiSelectEnd--;
            } else if (direction === 'right' && this.state.multiSelectEnd < this.config.SEQUENCER_STEPS - 1) {
                this.state.multiSelectEnd++;
            }

            this.state.selectedStep = this.state.multiSelectEnd;
        }

        _clearMultiSelect() {
            this.state.isMultiSelecting = false;
            this.state.multiSelectStart = -1;
            this.state.multiSelectEnd = -1;
        }

        _handleSequencerToggle() {
            if (this.state.isMultiSelecting) {
                const start = Math.min(this.state.multiSelectStart, this.state.multiSelectEnd);
                const end = Math.max(this.state.multiSelectStart, this.state.multiSelectEnd);
                
                for (let step = start; step <= end; step++) {
                    this._toggleSequencerStep(this.state.selectedSlot, step);
                }
            } else {
                this._toggleSequencerStep(this.state.selectedSlot, this.state.selectedStep);
            }
            
            this.saveCurrentState();
        }

        _handleSequencerDelete() {
            if (this.state.isMultiSelecting) {
                const start = Math.min(this.state.multiSelectStart, this.state.multiSelectEnd);
                const end = Math.max(this.state.multiSelectStart, this.state.multiSelectEnd);
                
                for (let step = start; step <= end; step++) {
                    this._setSequencerStep(this.state.selectedSlot, step, false);
                }
            } else {
                this._setSequencerStep(this.state.selectedSlot, this.state.selectedStep, false);
            }
            
            this.saveCurrentState();
        }

        _toggleSequencerStep(slot, step) {
            this.state.sequencerPatterns[slot][step] = !this.state.sequencerPatterns[slot][step];
            const stepElement = document.querySelector(`.step[data-slot='${slot}'][data-step='${step}']`);
            if (stepElement) {
                stepElement.classList.toggle("active", this.state.sequencerPatterns[slot][step]);
            }
        }

        _setSequencerStep(slot, step, isActive) {
            this.state.sequencerPatterns[slot][step] = isActive;
            const stepElement = document.querySelector(`.step[data-slot='${slot}'][data-step='${step}']`);
            if (stepElement) {
                stepElement.classList.toggle("active", isActive);
            }
        }

        _updateSequencerSelection() {
            document.querySelectorAll('.step.selected, .step.multi-selected').forEach(element => {
                element.classList.remove('selected', 'multi-selected');
            });

            if (this.state.isMultiSelecting) {
                const start = Math.min(this.state.multiSelectStart, this.state.multiSelectEnd);
                const end = Math.max(this.state.multiSelectStart, this.state.multiSelectEnd);
                
                for (let step = start; step <= end; step++) {
                    const stepElement = document.querySelector(
                        `.step[data-slot='${this.state.selectedSlot}'][data-step='${step}']`
                    );
                    if (stepElement) {
                        stepElement.classList.add('multi-selected');
                    }
                }
            } else {
                const selectedElement = document.querySelector(
                    `.step[data-slot='${this.state.selectedSlot}'][data-step='${this.state.selectedStep}']`
                );
                if (selectedElement) {
                    selectedElement.classList.add('selected');
                }
            }
        }

        _handleEscapeKey() {
            if (this.state.isMultiSelecting) {
                this._clearMultiSelect();
                this._updateSequencerSelection();
                return;
            }

            this.stopGranularPlayback();
            this.grainVoiceManager.stopAll();
            
            for (let s = 0; s < this.config.SLOTS; s++) {
                if (this.state.previewSources[s]) {
                    this.state.previewSources[s].stop();
                    this.state.previewSources[s].disconnect();
                    this.state.previewSources[s] = null;
                }
            }
        }

        _handleFileLoad(e) {
            const slot = parseInt(e.target.dataset.slot);
            const file = e.target.files[0];
            if (!file) return;

            file.arrayBuffer()
                .then(buf => this.audioContext.decodeAudioData(buf))
                .then(decoded => {
                    this.state.audioBuffers[slot] = decoded;
                    this.state.waveformRenderers[slot].drawWaveform(decoded);
                    document.getElementById(`fileName-slot${slot}`).textContent = file.name;
                    this.saveCurrentState();
                })
                .catch(err => console.error("Error loading audio file:", err));
        }
        
        _handleStepClick(cell) {
            const slot = +cell.dataset.slot;
            const step = +cell.dataset.step;
            this.state.sequencerPatterns[slot][step] = !this.state.sequencerPatterns[slot][step];
            cell.classList.toggle("active", this.state.sequencerPatterns[slot][step]);
            this.saveCurrentState();
        }

        _handleSlotShortcut(slot, type) {
            switch (type) {
                case 'solo':
                    if (this.state.slotSoloStatus[slot]) {
                        this.state.slotSoloStatus[slot] = false;
                    } else {
                        for (let i = 0; i < this.config.SLOTS; i++) {
                            this.state.slotSoloStatus[i] = false;
                        }
                        this.state.slotSoloStatus[slot] = true;
                        this.state.slotMuteStatus[slot] = false;
                    }
                    this._updateAllSlotControlButtons();
                    break;
                    
                case 'mute':
                    this.state.slotMuteStatus[slot] = !this.state.slotMuteStatus[slot];
                    if (this.state.slotMuteStatus[slot]) {
                        this.state.slotSoloStatus[slot] = false;
                    }
                    this._updateSlotControlButtons(slot);
                    break;
            }
            
            this.saveCurrentState();
        }

        _handleSlotControlClick(button) {
            const slot = parseInt(button.dataset.slot);
            const type = button.dataset.type;
            
            switch (type) {
                case 'solo':
                    if (this.state.slotSoloStatus[slot]) {
                        this.state.slotSoloStatus[slot] = false;
                    } else {
                        for (let i = 0; i < this.config.SLOTS; i++) {
                            this.state.slotSoloStatus[i] = false;
                        }
                        this.state.slotSoloStatus[slot] = true;
                        this.state.slotMuteStatus[slot] = false;
                    }
                    this._updateAllSlotControlButtons();
                    break;
                    
                case 'mute':
                    this.state.slotMuteStatus[slot] = !this.state.slotMuteStatus[slot];
                    if (this.state.slotMuteStatus[slot]) {
                        this.state.slotSoloStatus[slot] = false;
                    }
                    this._updateSlotControlButtons(slot);
                    break;
            }
            
            this.saveCurrentState();
        }

        _updateSlotControlButtons(slot) {
            const soloBtn = document.getElementById(`soloBtn-${slot}`);
            const muteBtn = document.getElementById(`muteBtn-${slot}`);
            
            if (this.state.slotSoloStatus[slot]) {
                soloBtn.classList.add('solo-active');
            } else {
                soloBtn.classList.remove('solo-active');
            }
            
            if (this.state.slotMuteStatus[slot]) {
                muteBtn.classList.add('mute-active');
            } else {
                muteBtn.classList.remove('mute-active');
            }
        }

        _updateAllSlotControlButtons() {
            for (let s = 0; s < this.config.SLOTS; s++) {
                this._updateSlotControlButtons(s);
            }
        }

        _isSlotActiveForPlayback(slot) {
            const hasSoloActive = this.state.slotSoloStatus.some(solo => solo);
            if (hasSoloActive) {
                return this.state.slotSoloStatus[slot];
            }
            return !this.state.slotMuteStatus[slot];
        }

        _onWaveformPlaybackStart(e, slotIndex) {
            if (this.state.audioBuffers[slotIndex] && !this.state.previewSources[slotIndex]) {
                const src = this.audioContext.createBufferSource();
                src.buffer = this.state.audioBuffers[slotIndex];
                
                const volumeElementId = `volume-slot${slotIndex}`;
                const volumeValue = this._getKnobValue(volumeElementId) || 0.7;
                
                const previewGain = this.audioContext.createGain();
                previewGain.gain.value = volumeValue;
                
                src.connect(previewGain);
                previewGain.connect(this.grainVoiceManager.masterGain);
                src.loop = true;
                src.start(0);
                this.state.previewSources[slotIndex] = src;
            }
            e.preventDefault();
        }

        _onWaveformPlaybackStop(e, slotIndex) {
            if (this.state.previewSources[slotIndex]) {
                this.state.previewSources[slotIndex].stop();
                this.state.previewSources[slotIndex].disconnect();
                this.state.previewSources[slotIndex] = null;
            }
            e.preventDefault();
        }

        startGranularPlayback() {
            if (this.state.isPlaying) {
                clearInterval(this.state.sequencerIntervalId);
            } else {
                this.state.isPlaying = true;
                this.state.lfoStartTime = this.audioContext.currentTime;
                this.state.currentSequencerStep = 0;
                
                if (this.spectrumAnalyzer) {
                    this.spectrumAnalyzer.start();
                }
            }

            const stepIntervalMs = (60 / this.state.tempoBpm) * 1000 / this.config.GRANULAR_INTERVAL_DIVISOR;
            this.state.sequencerIntervalId = setInterval(() => this._sequencerTick(), stepIntervalMs);
        }

        stopGranularPlayback() {
            if (!this.state.isPlaying) return;
            this.state.isPlaying = false;
            clearInterval(this.state.sequencerIntervalId);
            this._updateStepUI();

            this.grainVoiceManager.stopAll();
            
            if (this.spectrumAnalyzer) {
                this.spectrumAnalyzer.stop();
            }

            for (let s = 0; s < this.config.SLOTS; s++) {
                const buffer = this.state.audioBuffers[s];
                if (buffer) {
                    this.state.waveformRenderers[s].drawWaveform(buffer);
                } else {
                    this.state.waveformRenderers[s].ctx.clearRect(0, 0, this.state.waveformRenderers[s].canvas.width, this.state.waveformRenderers[s].canvas.height);
                    document.getElementById(`fileName-slot${s}`).textContent = '';
                }
            }
        }
        
        _sequencerTick() {
            const slotMode = parseInt(document.getElementById('slotMode').value);
            let targetSlots = [];

            if (slotMode === 4) {
                targetSlots = Array.from({ length: this.config.SLOTS }, (_, i) => i);
            } else if (slotMode === 5) {
                const randomSlot = this._pickRandomLoadedSlot();
                if (randomSlot !== null) targetSlots.push(randomSlot);
            } else {
                targetSlots.push(slotMode);
            }

            targetSlots.forEach(s => {
                if (this.state.audioBuffers[s] && 
                    this.state.sequencerPatterns[s][this.state.currentSequencerStep] && 
                    this._isSlotActiveForPlayback(s)) {
                    this._triggerGrainForSlot(s);
                }
            });

            this._updateStepUI();
            this.state.currentSequencerStep = (this.state.currentSequencerStep + 1) % this.config.SEQUENCER_STEPS;
        }

        _triggerGrainForSlot(targetSlot) {
            const buffer = this.state.audioBuffers[targetSlot];
            if (!buffer) return;

            const params = {};
            this.config.PER_SLOT_CONTROL_SPECS.forEach(spec => {
                const elementId = `${spec.id}-slot${targetSlot}`;
                params[spec.id] = this._getKnobValue(elementId);
            });

            const maxGrains = Math.min(params.grainsPerStep, 20);
            const spreadAmount = params.spread / 100;
            
            for (let i = 0; i < maxGrains; i++) {
                const now = this.audioContext.currentTime;
                const lfoTime = now - this.state.lfoStartTime;
                const lfoVal = this._getLFOValue(params.lfoWaveform, params.lfoRate, lfoTime);
                
                const grainDurSec = params.grainSize / 1000;
                let baseStartPosition = (params.startOffset / 100) * buffer.duration;
                baseStartPosition += lfoVal * (buffer.duration - baseStartPosition - grainDurSec);
                
                let positionSec = baseStartPosition;
                if (spreadAmount > 0) {
                    const positionSpread = spreadAmount * buffer.duration * 0.5;
                    const randomOffset = (Math.random() - 0.5) * 2 * positionSpread;
                    positionSec = baseStartPosition + randomOffset;
                }
                
                positionSec = Math.max(0, Math.min(buffer.duration - grainDurSec, positionSec + (Math.random() - 0.5) * 0.05));

                const spreadParams = { ...params };
                
                if (spreadAmount > 0) {
                    const pitchSpreadRange = spreadAmount * 0.5;
                    const pitchVariation = 1 + (Math.random() - 0.5) * 2 * pitchSpreadRange;
                    spreadParams.playbackRate = Math.max(0.1, Math.min(2.0, params.playbackRate * pitchVariation));
                    
                    const panSpreadRange = spreadAmount * 2;
                    const panVariation = (Math.random() - 0.5) * 2 * panSpreadRange;
                    spreadParams.panControl = Math.max(-1, Math.min(1, params.panControl + panVariation));
                }

                if (i % 4 === 0) {
                    this._flashSlot(targetSlot, positionSec);
                }

                let grainStartTime = now;
                if (spreadAmount > 0) {
                    const timingSpread = spreadAmount * 0.02;
                    grainStartTime += (Math.random() - 0.5) * 2 * timingSpread;
                }
                
                this.grainVoiceManager.createGrain(buffer, spreadParams, grainStartTime, grainDurSec, positionSec);
            }
        }
        
        _getLFOValue(waveformType, rate, time) {
            const waveformIndex = parseInt(waveformType);
            switch (waveformIndex) {
                case 0: return (Math.sin(2 * Math.PI * rate * time) + 1) / 2;
                case 1: return 1 - Math.abs(((time * rate) % 2) - 1);
                case 2: return ((time * rate) % 1) < 0.5 ? 0 : 1;
                case 3: return Math.random();
                default: return 0.5;
            }
        }

        _pickRandomLoadedSlot() {
            const available = this.state.audioBuffers
                .map((b, i) => (b && this._isSlotActiveForPlayback(i) ? i : null))
                .filter(i => i !== null);
            if (available.length === 0) return null;
            return available[Math.floor(Math.random() * available.length)];
        }

        _flashSlot(slotIndex, positionSec) {
            const buffer = this.state.audioBuffers[slotIndex];
            if (buffer) {
                this.state.waveformRenderers[slotIndex].drawPlayhead(buffer, positionSec);
            }
        }
        
        _updateStepUI() {
            const currentSteps = document.querySelectorAll('.step.current');
            currentSteps.forEach(step => step.classList.remove('current'));
            
            if (this.state.isPlaying) {
                const newCurrentSteps = document.querySelectorAll(`.step[data-step='${this.state.currentSequencerStep}']`);
                newCurrentSteps.forEach(step => step.classList.add('current'));
            }
        }

        _updateBpmKnob(value) {
            this.state.tempoBpm = Math.max(this.config.MIN_BPM, Math.min(this.config.MAX_BPM, value));
            
            if (this.state.knobDragStates['bpm']) {
                this.state.knobDragStates['bpm'].currentValue = this.state.tempoBpm;
            }
            
            this._updateKnobDisplay('bpm', this.config.BPM_SPEC, this.state.tempoBpm);
            
            if (this.state.isPlaying) {
                this.startGranularPlayback();
            }
        }
        
        _updateRandomDensityKnob(value) {
            let randomDensityValue = Math.max(this.config.MIN_RANDOM_DENSITY, Math.min(this.config.MAX_RANDOM_DENSITY, value));
            randomDensityValue = Math.round(randomDensityValue);
            
            if (this.state.knobDragStates['randomDensity']) {
                this.state.knobDragStates['randomDensity'].currentValue = randomDensityValue;
            }
            
            this._updateKnobDisplay('randomDensity', this.config.RANDOM_DENSITY_SPEC, randomDensityValue);
        }
        
        _updateUndoRedoButtons() {
            this.ui.undoButton.disabled = this.state.historyIndex <= 0;
            this.ui.redoButton.disabled = this.state.historyIndex >= this.state.history.length - 1;
        }

        randomizeSequencer() {
            const threshold = this._getKnobValue('randomDensity') / 100;
            let generatedSteps = 0;
            
            for (let slot = 0; slot < this.config.SLOTS; slot++) {
                for (let i = 0; i < this.config.SEQUENCER_STEPS; i++) {
                    const on = Math.random() < threshold;
                    this.state.sequencerPatterns[slot][i] = on;
                    document.querySelector(`.step[data-slot='${slot}'][data-step='${i}']`)?.classList.toggle('active', on);
                    if (on) generatedSteps++;
                }
            }
            
            console.log(`üé≤ „É©„É≥„ÉÄ„É†„Ç∑„Éº„Ç±„É≥„ÇπÁîüÊàê: ${Math.round(threshold * 100)}% Density ‚Üí ${generatedSteps}/${this.config.SLOTS * this.config.SEQUENCER_STEPS} „Çπ„ÉÜ„ÉÉ„ÉóON`);
            this.saveCurrentState();
        }

        randomizeAllSlotParams() {
            let randomizedCount = 0;
            let lockedCount = 0;
            
            for (let s = 0; s < this.config.SLOTS; s++) {
                this.config.PER_SLOT_CONTROL_SPECS.forEach(spec => {
                    const elementId = `${spec.id}-slot${s}`;
                    
                    if (this._isKnobLocked(elementId)) {
                        lockedCount++;
                        return;
                    }
                    
                    if (spec.id === 'volume') {
                        return;
                    }
                    
                    let randomValue;
                    const min = spec.min;
                    const max = spec.max;
                    const step = spec.step || 1;
                    randomValue = Math.random() * (max - min) + min;
                    randomValue = Math.round(randomValue / step) * step;
                    
                    if (this.state.knobDragStates[elementId]) {
                        this.state.knobDragStates[elementId].currentValue = randomValue;
                    }
                    
                    this._updateKnobDisplay(elementId, spec, randomValue);
                    randomizedCount++;
                });
            }
            
            this.saveCurrentState();
        }

        clearAllPan() {
            let clearedCount = 0;
            let lockedCount = 0;
            
            for (let s = 0; s < this.config.SLOTS; s++) {
                const panElementId = `panControl-slot${s}`;
                const panRandomElementId = `panRandom-slot${s}`;
                
                if (!this._isKnobLocked(panElementId)) {
                    if (this.state.knobDragStates[panElementId]) {
                        this.state.knobDragStates[panElementId].currentValue = 0;
                    }
                    
                    const panSpec = this.config.PER_SLOT_CONTROL_SPECS.find(spec => spec.id === 'panControl');
                    if (panSpec) {
                        this._updateKnobDisplay(panElementId, panSpec, 0);
                        clearedCount++;
                    }
                } else {
                    lockedCount++;
                }
                
                if (!this._isKnobLocked(panRandomElementId)) {
                    if (this.state.knobDragStates[panRandomElementId]) {
                        this.state.knobDragStates[panRandomElementId].currentValue = 0;
                    }
                    
                    const panRandomSpec = this.config.PER_SLOT_CONTROL_SPECS.find(spec => spec.id === 'panRandom');
                    if (panRandomSpec) {
                        this._updateKnobDisplay(panRandomElementId, panRandomSpec, 0);
                        clearedCount++;
                    }
                } else {
                    lockedCount++;
                }
            }
            
            this.saveCurrentState();
        }

        setHpf(frequency) {
            let setCount = 0;
            let lockedCount = 0;
            
            for (let s = 0; s < this.config.SLOTS; s++) {
                const elementId = `cutoffFreq-slot${s}`;
                const spec = this.config.PER_SLOT_CONTROL_SPECS.find(spec => spec.id === 'cutoffFreq');
                
                if (spec) {
                    if (this._isKnobLocked(elementId)) {
                        lockedCount++;
                        continue;
                    }
                    
                    const valueToSet = Math.max(spec.min, Math.min(spec.max, frequency));
                    
                    if (this.state.knobDragStates[elementId]) {
                        this.state.knobDragStates[elementId].currentValue = valueToSet;
                    }
                    
                    this._updateKnobDisplay(elementId, spec, valueToSet);
                    setCount++;
                }
            }
            
            this.saveCurrentState();
        }

        setAttackTime(attackTime) {
            let setCount = 0;
            let lockedCount = 0;
            
            for (let s = 0; s < this.config.SLOTS; s++) {
                const elementId = `attackTime-slot${s}`;
                const spec = this.config.PER_SLOT_CONTROL_SPECS.find(spec => spec.id === 'attackTime');
                
                if (spec) {
                    if (this._isKnobLocked(elementId)) {
                        lockedCount++;
                        continue;
                    }
                    
                    if (this.state.knobDragStates[elementId]) {
                        this.state.knobDragStates[elementId].currentValue = attackTime;
                    }
                    
                    this._updateKnobDisplay(elementId, spec, attackTime);
                    setCount++;
                }
            }
            
            this.saveCurrentState();
        }

        setPercussivePreset() {
            const presetValues = {
                'startOffset': 0,
                'attackTime': 3,
                'envelopeShape': 1,
                'lfoRate': 5.0,
                'lfoWaveform': 3,
                'decayTime': 450,
                'panControl': 0,
                'panRandom': 0.02,
                'spread': 25
            };

            let setCount = 0;
            let lockedCount = 0;

            for (let s = 0; s < this.config.SLOTS; s++) {
                Object.entries(presetValues).forEach(([paramId, value]) => {
                    const elementId = `${paramId}-slot${s}`;
                    const spec = this.config.PER_SLOT_CONTROL_SPECS.find(spec => spec.id === paramId);
                    
                    if (spec) {
                        if (this._isKnobLocked(elementId)) {
                            lockedCount++;
                            return;
                        }
                        
                        const clampedValue = Math.max(spec.min, Math.min(spec.max, value));
                        
                        if (this.state.knobDragStates[elementId]) {
                            this.state.knobDragStates[elementId].currentValue = clampedValue;
                        }
                        
                        this._updateKnobDisplay(elementId, spec, clampedValue);
                        setCount++;
                    }
                });
            }
            
            this.saveCurrentState();
        }

        async _loadFolderSamples() {
            this.ui.loadPathButton.disabled = true;
            this.ui.loadPathButton.textContent = 'Loading...';
            this.ui.loadingStatus.textContent = 'Loading';
            this.ui.loadingStatus.classList.add('loading-dots');

            try {
                if (!window.showDirectoryPicker) {
                    alert("File System Access API not supported");
                    return;
                }

                const dirHandle = await window.showDirectoryPicker();
                let allFileHandles = await this._getAllAudioFilesRecursive(dirHandle);

                const filterString = document.getElementById('loadPathInput').value.toLowerCase().trim();
                if (filterString) {
                    allFileHandles = allFileHandles.filter(handle => handle.name.toLowerCase().includes(filterString));
                }

                if (allFileHandles.length === 0) {
                    alert("No matching audio files found");
                    return;
                }
                
                for (let s = 0; s < this.config.SLOTS; s++) {
                    this.state.audioBuffers[s] = null;
                    this.state.waveformRenderers[s].invalidateCache();
                    this.state.waveformRenderers[s].ctx.clearRect(0, 0, this.config.WAVEFORM_CANVAS_WIDTH, this.config.WAVEFORM_CANVAS_HEIGHT);
                    document.getElementById(`fileName-slot${s}`).textContent = '';
                }

                for (let i = allFileHandles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allFileHandles[i], allFileHandles[j]] = [allFileHandles[j], allFileHandles[i]];
                }

                const loadPromises = allFileHandles.slice(0, this.config.SLOTS).map((fileHandle, index) =>
                    this._processAndLoadFile(fileHandle, index)
                );
                
                await Promise.all(loadPromises);
                
                const loadedCount = this.state.audioBuffers.filter(b => b).length;
                this.ui.loadingStatus.textContent = `${loadedCount}/${this.config.SLOTS} loaded`;
                this.saveCurrentState();

            } catch (err) {
                console.error("Load error:", err);
                this.ui.loadingStatus.textContent = 'Error!';
            } finally {
                this.ui.loadPathButton.disabled = false;
                this.ui.loadPathButton.textContent = 'Load';
                this.ui.loadingStatus.classList.remove('loading-dots');
            }
        }

        async _getAllAudioFilesRecursive(dirHandle, files = []) {
            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file' && (entry.name.toLowerCase().endsWith('.wav') || entry.name.toLowerCase().endsWith('.mp3'))) {
                    files.push(entry);
                } else if (entry.kind === 'directory') {
                    await this._getAllAudioFilesRecursive(entry, files);
                }
            }
            return files;
        }

        async _processAndLoadFile(fileHandle, slotIndex) {
            try {
                const file = await fileHandle.getFile();
                const arrayBuffer = await file.arrayBuffer();
                const decodedData = await this.audioContext.decodeAudioData(arrayBuffer);
                
                const rawData = decodedData.getChannelData(0);
                const sampleRate = decodedData.sampleRate;
                const threshold = 0.01;
                let startIdx = 0, endIdx = rawData.length - 1;
                
                while (startIdx < rawData.length && Math.abs(rawData[startIdx]) < threshold) startIdx++;
                while (endIdx > startIdx && Math.abs(rawData[endIdx]) < threshold) endIdx--;
                
                const trimmedLength = endIdx - startIdx + 1;
                if (trimmedLength <= 0) return;

                const trimmedBuffer = this.audioContext.createBuffer(1, trimmedLength, sampleRate);
                trimmedBuffer.copyToChannel(rawData.subarray(startIdx, endIdx + 1), 0);
                
                const data = trimmedBuffer.getChannelData(0);
                const max = data.reduce((max, val) => Math.max(max, Math.abs(val)), 0);
                if (max > 0) {
                    for(let i = 0; i < data.length; i++) data[i] /= max;
                }
                
                this.state.audioBuffers[slotIndex] = trimmedBuffer;
                this.state.waveformRenderers[slotIndex].drawWaveform(trimmedBuffer);
                document.getElementById(`fileName-slot${slotIndex}`).textContent = file.name;
            } catch (error) {
                console.error(`Error processing ${fileHandle.name}:`, error);
                document.getElementById(`fileName-slot${slotIndex}`).textContent = 'Error!';
            }
        }

        _getControlState() {
            const collapsedStates = {};
            
            if (!this.state.isFreeLayoutMode) {
                document.querySelectorAll('.panel-group').forEach(panel => {
                    const content = panel.querySelector('[id$="-content"]');
                    if (content) {
                        collapsedStates[panel.id] = content.classList.contains('collapsed-content');
                    }
                });
            }
            
            return {
                globalControls: { slotMode: document.getElementById('slotMode').value },
                perSlotControls: Array.from({ length: this.config.SLOTS }, (_, s) => {
                    const slotState = {};
                    this.config.PER_SLOT_CONTROL_SPECS.forEach(spec => {
                        const elementId = `${spec.id}-slot${s}`;
                        slotState[spec.id] = this._getKnobValue(elementId);
                    });
                    return slotState;
                }),
                sequencerPatterns: JSON.parse(JSON.stringify(this.state.sequencerPatterns)),
                slotSoloStatus: JSON.parse(JSON.stringify(this.state.slotSoloStatus)),
                slotMuteStatus: JSON.parse(JSON.stringify(this.state.slotMuteStatus)),
                tempoBpm: this.state.tempoBpm,
                randomDensity: this._getKnobValue('randomDensity'),
                knobLockStates: JSON.parse(JSON.stringify(this.state.knobLockStates)),
                collapsedStates: collapsedStates
            };
        }

        _applyState(state) {
            document.getElementById('slotMode').value = state.globalControls.slotMode;
            
            state.perSlotControls.forEach((slotState, s) => {
                for (const id in slotState) {
                    const elementId = `${id}-slot${s}`;
                    const spec = this.config.PER_SLOT_CONTROL_SPECS.find(spec => spec.id === id);
                    
                    if (spec && this.state.knobDragStates[elementId]) {
                        this.state.knobDragStates[elementId].currentValue = slotState[id];
                        this._updateKnobDisplay(elementId, spec, slotState[id]);
                    }
                }
            });

            this.state.sequencerPatterns = JSON.parse(JSON.stringify(state.sequencerPatterns));
            this.state.sequencerPatterns.forEach((pattern, slot) => {
                pattern.forEach((isActive, step) => {
                    document.querySelector(`.step[data-slot='${slot}'][data-step='${step}']`)?.classList.toggle("active", isActive);
                });
            });

            this.state.slotSoloStatus = JSON.parse(JSON.stringify(state.slotSoloStatus));
            this.state.slotMuteStatus = JSON.parse(JSON.stringify(state.slotMuteStatus));
            
            if (state.knobLockStates) {
                this.state.knobLockStates = JSON.parse(JSON.stringify(state.knobLockStates));
                
                Object.entries(this.state.knobLockStates).forEach(([elementId, isLocked]) => {
                    const knobElement = document.getElementById(`${elementId}Knob`);
                    if (knobElement) {
                        if (isLocked) {
                            knobElement.classList.add('locked');
                        } else {
                            knobElement.classList.remove('locked');
                        }
                        knobElement.style.cursor = 'grab';
                    }
                });
            }
            
            this._updateAllSlotControlButtons();
            
            if (!this.state.isFreeLayoutMode && state.collapsedStates) {
                Object.entries(state.collapsedStates).forEach(([panelId, isCollapsed]) => {
                    const panel = document.getElementById(panelId);
                    if (panel) {
                        const content = panel.querySelector('[id$="-content"]');
                        const indicator = panel.querySelector('.indicator');
                        if (content && indicator) {
                            content.classList.toggle('collapsed-content', isCollapsed);
                            indicator.textContent = isCollapsed ? '+' : '-';
                        }
                    }
                });
            }
            
            this._updateRandomDensityKnob(state.randomDensity);
            this._updateBpmKnob(state.tempoBpm);
            this._updateUndoRedoButtons();
        }

        saveCurrentState() {
            if (this.state.historyIndex < this.state.history.length - 1) {
                this.state.history = this.state.history.slice(0, this.state.historyIndex + 1);
            }
            this.state.history.push(this._getControlState());
            if (this.state.history.length > this.config.MAX_HISTORY_STATES) {
                this.state.history.shift();
            }
            this.state.historyIndex = this.state.history.length - 1;
            this._updateUndoRedoButtons();
        }

        undo() {
            if (this.state.historyIndex > 0) {
                this.state.historyIndex--;
                this._applyState(this.state.history[this.state.historyIndex]);
            }
        }

        redo() {
            if (this.state.historyIndex < this.state.history.length - 1) {
                this.state.historyIndex++;
                this._applyState(this.state.history[this.state.historyIndex]);
            }
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const player = new OptimizedMultigrainPlayer();
        player.init();
    });
  </script>
</body>
</html>